# å›¾åƒå‹ç¼©è¯¦è§£ ğŸ“¦

> æ¬¢è¿æ¥åˆ°å›¾åƒå¤„ç†çš„"å‹ç¼©è‰ºæœ¯é¦†"ï¼åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•åƒä¸€ä½"æ•°å­—é­”æœ¯å¸ˆ"ä¸€æ ·ï¼Œé€šè¿‡å·§å¦™çš„å‹ç¼©æŠ€æœ¯ï¼Œåœ¨ä¿æŒå›¾åƒå“è´¨çš„åŒæ—¶å¤§å¹…ç¼©å°æ–‡ä»¶ä½“ç§¯ã€‚è®©æˆ‘ä»¬å¼€å§‹è¿™åœºæ•°å­—ä¸–ç•Œçš„"ç©ºé—´æŠ˜å ä¹‹æ—…"å§ï¼ğŸ¨

## ç›®å½•
- [1. å›¾åƒå‹ç¼©ç®€ä»‹](#1-å›¾åƒå‹ç¼©ç®€ä»‹)
- [2. æ— æŸå‹ç¼©ï¼šå®Œç¾ä¿å­˜](#2-æ— æŸå‹ç¼©å®Œç¾ä¿å­˜)
- [3. JPEGå‹ç¼©ï¼šæ™ºèƒ½å‹ç¼©](#3-jpegå‹ç¼©æ™ºèƒ½å‹ç¼©)
- [4. åˆ†å½¢å‹ç¼©ï¼šè‡ªç›¸ä¼¼å‹ç¼©](#4-åˆ†å½¢å‹ç¼©è‡ªç›¸ä¼¼å‹ç¼©)
- [5. å°æ³¢å‹ç¼©ï¼šå¤šå°ºåº¦å‹ç¼©](#5-å°æ³¢å‹ç¼©å¤šå°ºåº¦å‹ç¼©)
- [6. å®é™…åº”ç”¨ä¸æ³¨æ„äº‹é¡¹](#6-å®é™…åº”ç”¨ä¸æ³¨æ„äº‹é¡¹)
- [7. æ€§èƒ½è¯„ä¼°ä¸å¯¹æ¯”](#7-æ€§èƒ½è¯„ä¼°ä¸å¯¹æ¯”)
- [8. æ€»ç»“](#8-æ€»ç»“)

## 1. å›¾åƒå‹ç¼©ç®€ä»‹

### 1.1 ä»€ä¹ˆæ˜¯å›¾åƒå‹ç¼©ï¼Ÿ ğŸ¤”

å›¾åƒå‹ç¼©å°±åƒæ˜¯æ•°å­—ä¸–ç•Œçš„"ç©ºé—´ç®¡ç†"ï¼š
- ğŸ“¦ å‡å°æ–‡ä»¶å¤§å°ï¼ˆå°±åƒå‹ç¼©è¡Œæä½“ç§¯ï¼‰
- ğŸ¯ ä¿æŒå›¾åƒè´¨é‡ï¼ˆå°±åƒä¿æŠ¤æ˜“ç¢ç‰©å“ï¼‰
- ğŸš€ æé«˜ä¼ è¾“æ•ˆç‡ï¼ˆå°±åƒå¿«é€Ÿè¿è¾“ï¼‰
- ğŸ’¾ èŠ‚çœå­˜å‚¨ç©ºé—´ï¼ˆå°±åƒä¼˜åŒ–ä»“å‚¨ï¼‰

### 1.2 ä¸ºä»€ä¹ˆéœ€è¦å›¾åƒå‹ç¼©ï¼Ÿ ğŸ’¡

- ğŸ“± æ‰‹æœºå­˜å‚¨æ€»æ˜¯å‘Šæ€¥ï¼ˆ"å­˜å‚¨ç©ºé—´åˆä¸å¤Ÿäº†ï¼"ï¼‰
- ğŸŒ ç½‘ç»œå¸¦å®½æ°¸è¿œä¸å«Œå¿«ï¼ˆ"è¿™å›¾æ€ä¹ˆè¿˜åœ¨åŠ è½½..."ï¼‰
- ğŸ’° å­˜å‚¨æˆæœ¬éœ€è¦æ§åˆ¶ï¼ˆ"äº‘å­˜å‚¨è´¦å•åˆè¶…æ”¯äº†"ï¼‰
- âš¡ åŠ è½½é€Ÿåº¦è¦å¤Ÿå¿«ï¼ˆ"ç”¨æˆ·ç­‰ä¸åŠäº†ï¼"ï¼‰

å¸¸è§çš„å‹ç¼©æ–¹æ³•åŒ…æ‹¬ï¼š
- æ— æŸå‹ç¼©ï¼ˆåƒæ˜¯"å®Œç¾æŠ˜å "ï¼‰
- JPEGå‹ç¼©ï¼ˆæ™ºèƒ½"å¼¹æ€§å‹ç¼©"ï¼‰
- åˆ†å½¢å‹ç¼©ï¼ˆåŸºäº"è‡ªç›¸ä¼¼æ€§"ï¼‰
- å°æ³¢å‹ç¼©ï¼ˆå¤šå±‚æ¬¡"ç²¾ç»†å‹ç¼©"ï¼‰

## 2. æ— æŸå‹ç¼©ï¼šå®Œç¾ä¿å­˜

æ— æŸå‹ç¼©å°±åƒæ˜¯"å®Œç¾æŠ˜å "çš„è‰ºæœ¯ï¼Œä¿è¯å›¾åƒè´¨é‡çš„åŒæ—¶å‡å°æ–‡ä»¶å¤§å°ã€‚å®ƒå°±åƒæ˜¯æŠŠè¡£æœå å¾—æ•´æ•´é½é½ï¼Œéœ€è¦æ—¶è¿˜èƒ½å®Œå…¨å±•å¼€æ¢å¤åŸæ ·ï¼ğŸ‘”

### 2.1 æ¸¸ç¨‹ç¼–ç (RLE)

æ¸¸ç¨‹ç¼–ç å°±åƒæ˜¯"é‡å¤å…ƒç´ çš„ç®€å†™å¤§å¸ˆ"ã€‚æ¯”å¦‚æŠŠ"ğŸŒŸğŸŒŸğŸŒŸğŸŒŸğŸŒŸ"ç®€å†™æˆ"5ä¸ªğŸŒŸ"ï¼Œæ—¢æ¸…æ™°åˆèŠ‚çœç©ºé—´ï¼

æ•°å­¦è¡¨è¾¾å¼ï¼š
$$
RLE(x_1^{n_1}x_2^{n_2}...x_k^{n_k}) = (x_1,n_1)(x_2,n_2)...(x_k,n_k)
$$

å…¶ä¸­ï¼š
- $x_i$ æ˜¯åƒç´ å€¼
- $n_i$ æ˜¯è¿ç»­å‡ºç°æ¬¡æ•°

#### C++å®ç°
```cpp
double rle_encode(const Mat& src, vector<uchar>& encoded) {
    CV_Assert(!src.empty());

    // è½¬æ¢ä¸ºç°åº¦å›¾
    Mat gray;
    if (src.channels() == 3) {
        cvtColor(src, gray, COLOR_BGR2GRAY);
    } else {
        gray = src.clone();
    }

    encoded.clear();
    encoded.reserve(gray.total());

    uchar current = gray.at<uchar>(0, 0);
    int count = 1;

    // RLEç¼–ç 
    for (int i = 1; i < gray.total(); i++) {
        uchar pixel = gray.at<uchar>(i / gray.cols, i % gray.cols);

        if (pixel == current && count < 255) {
            count++;
        } else {
            encoded.push_back(current);
            encoded.push_back(count);
            current = pixel;
            count = 1;
        }
    }

    // å¤„ç†æœ€åä¸€ç»„
    encoded.push_back(current);
    encoded.push_back(count);

    return compute_compression_ratio(gray.total(), encoded.size());
}
```

#### Pythonå®ç°
```python
def rle_compression(img_path):
    """
    é—®é¢˜47ï¼šæ— æŸå‹ç¼©ï¼ˆRLEç¼–ç ï¼‰
    ä½¿ç”¨æ¸¸ç¨‹ç¼–ç è¿›è¡Œæ— æŸå‹ç¼©

    å‚æ•°:
        img_path: è¾“å…¥å›¾åƒè·¯å¾„

    è¿”å›:
        å‹ç¼©åé‡å»ºçš„å›¾åƒ
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        raise ValueError(f"æ— æ³•è¯»å–å›¾åƒ: {img_path}")

    # å±•å¹³å›¾åƒ
    flat_img = img.flatten()

    # RLEç¼–ç 
    encoded = []
    count = 1
    current = flat_img[0]

    for pixel in flat_img[1:]:
        if pixel == current:
            count += 1
        else:
            encoded.extend([current, count])
            current = pixel
            count = 1
    encoded.extend([current, count])

    # RLEè§£ç 
    decoded = []
    for i in range(0, len(encoded), 2):
        decoded.extend([encoded[i]] * encoded[i+1])

    # é‡å»ºå›¾åƒ
    result = np.array(decoded).reshape(img.shape)

    # è½¬æ¢ä¸ºå½©è‰²å›¾åƒ
    result = cv2.cvtColor(result.astype(np.uint8), cv2.COLOR_GRAY2BGR)

    return result
```

### 2.2 éœå¤«æ›¼ç¼–ç 

éœå¤«æ›¼ç¼–ç å°±åƒæ˜¯"ç»™å¸¸ç”¨ç‰©å“åˆ†é…çŸ­ä»£å·"ï¼Œå¸¸è§çš„å€¼ç”¨çŸ­ç¼–ç è¡¨ç¤ºã€‚è¿™å°±åƒæ˜¯æˆ‘ä»¬ç»™å¸¸ç”¨çš„è¯ç”¨ç®€å†™ï¼Œä¸å¸¸ç”¨çš„è¯ç”¨å…¨ç§°ï¼Œæ—¢èŠ‚çœç©ºé—´åˆå®¹æ˜“ç†è§£ï¼

#### C++å®ç°
```cpp
struct HuffmanNode {
    uchar value;
    int frequency;
    HuffmanNode* left;
    HuffmanNode* right;

    HuffmanNode(uchar v, int f) : value(v), frequency(f), left(nullptr), right(nullptr) {}
};

class HuffmanEncoder {
private:
    HuffmanNode* root;
    map<uchar, string> code_table;

    void build_code_table(HuffmanNode* node, string code) {
        if (!node) return;
        if (!node->left && !node->right) {
            code_table[node->value] = code;
            return;
        }
        build_code_table(node->left, code + "0");
        build_code_table(node->right, code + "1");
    }

public:
    void encode(const Mat& src, vector<bool>& encoded) {
        // ç»Ÿè®¡é¢‘ç‡
        map<uchar, int> frequency;
        for (int i = 0; i < src.total(); i++) {
            frequency[src.at<uchar>(i / src.cols, i % src.cols)]++;
        }

        // æ„å»ºéœå¤«æ›¼æ ‘
        priority_queue<pair<int, HuffmanNode*>, vector<pair<int, HuffmanNode*>>, greater<>> pq;
        for (const auto& pair : frequency) {
            pq.push({pair.second, new HuffmanNode(pair.first, pair.second)});
        }

        while (pq.size() > 1) {
            auto left = pq.top().second; pq.pop();
            auto right = pq.top().second; pq.pop();
            auto parent = new HuffmanNode(0, left->frequency + right->frequency);
            parent->left = left;
            parent->right = right;
            pq.push({parent->frequency, parent});
        }

        root = pq.top().second;
        build_code_table(root, "");

        // ç¼–ç 
        encoded.clear();
        for (int i = 0; i < src.total(); i++) {
            uchar pixel = src.at<uchar>(i / src.cols, i % src.cols);
            string code = code_table[pixel];
            for (char bit : code) {
                encoded.push_back(bit == '1');
            }
        }
    }
};
```

#### Pythonå®ç°
```python
def huffman_encoding(data):
    """æ‰‹åŠ¨å®ç°éœå¤«æ›¼ç¼–ç """
    # ç»Ÿè®¡é¢‘ç‡
    frequency = collections.Counter(data)

    # æ„å»ºéœå¤«æ›¼æ ‘
    heap = [[weight, [symbol, ""]] for symbol, weight in frequency.items()]
    heapq.heapify(heap)

    while len(heap) > 1:
        lo = heapq.heappop(heap)
        hi = heapq.heappop(heap)
        for pair in lo[1:]:
            pair[1] = '0' + pair[1]
        for pair in hi[1:]:
            pair[1] = '1' + pair[1]
        heapq.heappush(heap, [lo[0] + hi[0]] + lo[1:] + hi[1:])

    return dict(heap[0][1:])
```

## 3. JPEGå‹ç¼©ï¼šæ™ºèƒ½å‹ç¼©

JPEGå‹ç¼©å°±åƒæ˜¯"æ™ºèƒ½å‹ç¼©å¤§å¸ˆ"ï¼Œå®ƒçŸ¥é“äººçœ¼å¯¹æŸäº›ç»†èŠ‚ä¸æ•æ„Ÿï¼Œæ‰€ä»¥å¯ä»¥"å·å·"ä¸¢æ‰ä¸€äº›ä¿¡æ¯ï¼Œä½†ä¿æŒå›¾åƒçœ‹èµ·æ¥ä¾ç„¶å¾ˆç¾ï¼ğŸ¨

### 3.1 è‰²å½©ç©ºé—´è½¬æ¢

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦æŠŠå›¾åƒä»RGBè½¬æ¢åˆ°YCbCrè‰²å½©ç©ºé—´ã€‚è¿™å°±åƒæ˜¯æŠŠå›¾åƒåˆ†è§£æˆäº®åº¦(Y)å’Œè‰²åº¦(Cb, Cr)ä¸¤ä¸ªéƒ¨åˆ†ã€‚äººçœ¼å¯¹äº®åº¦æ›´æ•æ„Ÿï¼Œå¯¹è‰²åº¦ä¸å¤ªæ•æ„Ÿï¼Œè¿™å°±æ˜¯JPEGå‹ç¼©çš„"ç§˜å¯†æ­¦å™¨"ï¼

æ•°å­¦è¡¨è¾¾å¼ï¼š
$$
\begin{bmatrix} Y \\ Cb \\ Cr \end{bmatrix} =
\begin{bmatrix}
0.299 & 0.587 & 0.114 \\
-0.1687 & -0.3313 & 0.5 \\
0.5 & -0.4187 & -0.0813
\end{bmatrix}
\begin{bmatrix} R \\ G \\ B \end{bmatrix}
$$

#### C++å®ç°
```cpp
void rgb_to_ycbcr(const Mat& src, Mat& y, Mat& cb, Mat& cr) {
    // åˆ†ç¦»é€šé“
    vector<Mat> channels;
    split(src, channels);
    Mat r = channels[2], g = channels[1], b = channels[0];

    // è½¬æ¢åˆ°YCbCr
    y = 0.299 * r + 0.587 * g + 0.114 * b;
    cb = -0.1687 * r - 0.3313 * g + 0.5 * b + 128;
    cr = 0.5 * r - 0.4187 * g - 0.0813 * b + 128;
}
```

#### Pythonå®ç°
```python
def rgb_to_ycbcr(img):
    """æ‰‹åŠ¨å®ç°RGBåˆ°YCbCrçš„è½¬æ¢"""
    # åˆ†ç¦»é€šé“
    b, g, r = cv2.split(img)

    # è½¬æ¢åˆ°YCbCr
    y = 0.299 * r + 0.587 * g + 0.114 * b
    cb = -0.1687 * r - 0.3313 * g + 0.5 * b + 128
    cr = 0.5 * r - 0.4187 * g - 0.0813 * b + 128

    return y, cb, cr
```

### 3.2 DCTå˜æ¢

DCTå˜æ¢å°±åƒæ˜¯ç»™å›¾åƒåš"é¢‘ç‡åˆ†æ"ï¼ŒæŠŠå›¾åƒåˆ†è§£æˆä¸åŒé¢‘ç‡çš„"éŸ³ç¬¦"ã€‚ä½é¢‘å°±åƒæ˜¯"ä¸»æ—‹å¾‹"ï¼Œé«˜é¢‘å°±åƒæ˜¯"è£…é¥°éŸ³"ï¼Œæˆ‘ä»¬è¦é‡ç‚¹ä¿æŠ¤"ä¸»æ—‹å¾‹"ï¼

æ•°å­¦è¡¨è¾¾å¼ï¼š
$$
F(u,v) = \frac{2}{N}C(u)C(v)\sum_{x=0}^{N-1}\sum_{y=0}^{N-1}f(x,y)\cos\left[\frac{(2x+1)u\pi}{2N}\right]\cos\left[\frac{(2y+1)v\pi}{2N}\right]
$$

å…¶ä¸­ï¼š
- $C(u) = \frac{1}{\sqrt{2}}$ å½“ $u=0$
- $C(u) = 1$ å½“ $u>0$

#### C++å®ç°
```cpp
void dct_transform(const Mat& src, Mat& dst) {
    const int N = 8;
    dst = Mat::zeros(src.size(), CV_32F);

    for (int u = 0; u < N; u++) {
        for (int v = 0; v < N; v++) {
            float sum = 0;
            float cu = (u == 0) ? 1.0/sqrt(2) : 1.0;
            float cv = (v == 0) ? 1.0/sqrt(2) : 1.0;

            for (int x = 0; x < N; x++) {
                for (int y = 0; y < N; y++) {
                    float cos_u = cos((2*x+1)*u*M_PI/(2*N));
                    float cos_v = cos((2*y+1)*v*M_PI/(2*N));
                    sum += src.at<float>(x,y) * cos_u * cos_v;
                }
            }

            dst.at<float>(u,v) = 2.0/N * cu * cv * sum;
        }
    }
}
```

#### Pythonå®ç°
```python
def dct_transform(block):
    """æ‰‹åŠ¨å®ç°DCTå˜æ¢"""
    N = 8
    result = np.zeros((N, N), dtype=np.float32)

    for u in range(N):
        for v in range(N):
            sum_val = 0
            cu = 1/np.sqrt(2) if u == 0 else 1
            cv = 1/np.sqrt(2) if v == 0 else 1

            for x in range(N):
                for y in range(N):
                    cos_u = np.cos((2*x+1)*u*np.pi/(2*N))
                    cos_v = np.cos((2*y+1)*v*np.pi/(2*N))
                    sum_val += block[x,y] * cos_u * cos_v

            result[u,v] = 2/N * cu * cv * sum_val

    return result
```

### 3.3 é‡åŒ–

é‡åŒ–æ˜¯JPEGå‹ç¼©ä¸­æœ€å…³é”®çš„ä¸€æ­¥ï¼Œå°±åƒæ˜¯ä¸€ä½ç²¾æ˜çš„"æ•°å­—ä¼šè®¡å¸ˆ" ğŸ“Šã€‚æˆ‘ä»¬ç”¨ä¸€ä¸ªé‡åŒ–è¡¨æ¥å¯¹DCTç³»æ•°è¿›è¡Œ"æ™ºèƒ½åŒ–ç®€"ï¼Œé«˜é¢‘éƒ¨åˆ†ï¼ˆç»†èŠ‚ï¼‰ä¼šè¢«æ›´å¤§å¹…åº¦åœ°å‹ç¼©ã€‚è¿™å°±åƒæ˜¯åœ¨å¤„ç†è´¢åŠ¡æŠ¥è¡¨æ—¶ï¼Œé‡è¦çš„æ•°å­—ä¿ç•™åˆ°å°æ•°ç‚¹åä¸¤ä½ï¼Œæ¬¡è¦çš„æ•°å­—ç›´æ¥å–æ•´ï¼Œæœ€ä¸é‡è¦çš„æ•°å­—å¯ä»¥çœç•¥ä¸è®¡ï¼

JPEGæ ‡å‡†çš„äº®åº¦é‡åŒ–è¡¨ï¼ˆè´¨é‡å› å­=50ï¼‰å°±åƒæ˜¯ä¸€å¼ "å›¾åƒç˜¦èº«è®¡åˆ’è¡¨"ï¼š
```
16  11  10  16  24  40  51  61  â† ä¿ç•™é‡è¦ä¿¡æ¯
12  12  14  19  26  58  60  55
14  13  16  24  40  57  69  56
14  17  22  29  51  87  80  62  â† æ¸è¿›å‹ç¼©
18  22  37  56  68 109 103  77
24  35  55  64  81 104 113  92
49  64  78  87 103 121 120 101
72  92  95  98 112 100 103  99  â† å¤§èƒ†å‹ç¼©ç»†èŠ‚
```

è¿™ä¸ªé‡åŒ–è¡¨çš„è®¾è®¡å¯è°“æ˜¯"å·§å¤ºå¤©å·¥"ï¼š
- å·¦ä¸Šè§’çš„å€¼è¾ƒå°ï¼šåƒæ˜¯å¯¹å¾…"VIPå®¢æˆ·"ä¸€æ ·ç²¾å¿ƒä¿ç•™ä½é¢‘ä¿¡æ¯ï¼ˆæ•´ä½“ç»“æ„ï¼‰
- å³ä¸‹è§’çš„å€¼è¾ƒå¤§ï¼šåƒæ˜¯å¯¹å¾…"ä¸´æ—¶è®¿å®¢"ä¸€æ ·å¤§èƒ†å‹ç¼©é«˜é¢‘ä¿¡æ¯ï¼ˆç»†èŠ‚ï¼‰
- å¯¹è§’çº¿æ–¹å‘æ¸å˜ï¼šåƒæ˜¯è®¾è®¡äº†ä¸€æ¡"å¹³æ»‘è¿‡æ¸¡å¸¦"ï¼Œè®©å‹ç¼©æ•ˆæœè‡ªç„¶ä¸çªå…€

é‡åŒ–è¿‡ç¨‹çš„æ•°å­¦è¡¨è¾¾å¼çœ‹èµ·æ¥å¾ˆç®€å•ï¼Œä½†æ•ˆæœå´å‡ºå¥‡åœ°å¥½ï¼š
$$
F_Q(u,v) = round\left(\frac{F(u,v)}{Q(u,v)}\right)
$$

è¿™ä¸ªå…¬å¼ä¸­çš„æ¯ä¸ªç¬¦å·éƒ½åƒæ˜¯åœ¨æ¼”ç»ä¸åŒçš„è§’è‰²ï¼š
- $F(u,v)$ æ˜¯DCTç³»æ•°ï¼Œåƒæ˜¯åŸå§‹çš„"æ•°å­—èµ„äº§"
- $Q(u,v)$ æ˜¯é‡åŒ–è¡¨ä¸­çš„å€¼ï¼Œåƒæ˜¯"å‹ç¼©æ¯”ä¾‹å°º"
- $F_Q(u,v)$ æ˜¯é‡åŒ–åçš„ç³»æ•°ï¼Œåƒæ˜¯"ç²¾ç®€åçš„èµ„äº§è´¦æœ¬"
- $round()$ å‡½æ•°åƒæ˜¯ä¸€ä½"æœæ–­çš„å†³ç­–è€…"ï¼Œè´Ÿè´£æœ€ç»ˆçš„å–èˆ

#### C++å®ç°
```cpp
void quantize(Mat& dct_coeffs, const Mat& quant_table) {
    for (int i = 0; i < dct_coeffs.rows; i++) {
        for (int j = 0; j < dct_coeffs.cols; j++) {
            dct_coeffs.at<float>(i,j) = round(dct_coeffs.at<float>(i,j) / quant_table.at<float>(i,j));
        }
    }
}
```

#### Pythonå®ç°
```python
def quantize(dct_coeffs, quant_table):
    """æ‰‹åŠ¨å®ç°é‡åŒ–"""
    return np.round(dct_coeffs / quant_table)
```

#### å®Œæ•´çš„JPEGå®ç°(Python)
```python
def jpeg_compression(img_path, quality=50):
    """
    é—®é¢˜48ï¼šJPEGå‹ç¼©
    ä½¿ç”¨DCTå˜æ¢å’Œé‡åŒ–è¿›è¡ŒJPEGå‹ç¼©

    å‚æ•°:
        img_path: è¾“å…¥å›¾åƒè·¯å¾„
        quality: å‹ç¼©è´¨é‡(1-100)ï¼Œé»˜è®¤50

    è¿”å›:
        å‹ç¼©åé‡å»ºçš„å›¾åƒ
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        raise ValueError(f"æ— æ³•è¯»å–å›¾åƒ: {img_path}")

    # æ ‡å‡†JPEGé‡åŒ–è¡¨
    Q = np.array([[16, 11, 10, 16, 24, 40, 51, 61],
                  [12, 12, 14, 19, 26, 58, 60, 55],
                  [14, 13, 16, 24, 40, 57, 69, 56],
                  [14, 17, 22, 29, 51, 87, 80, 62],
                  [18, 22, 37, 56, 68, 109, 103, 77],
                  [24, 35, 55, 64, 81, 104, 113, 92],
                  [49, 64, 78, 87, 103, 121, 120, 101],
                  [72, 92, 95, 98, 112, 100, 103, 99]])

    # è°ƒæ•´é‡åŒ–è¡¨æ ¹æ®è´¨é‡å‚æ•°
    if quality < 50:
        S = 5000 / quality
    else:
        S = 200 - 2 * quality
    Q = np.floor((S * Q + 50) / 100)
    Q = np.clip(Q, 1, 255)

    # åˆ†å—å¤„ç†
    h, w = img.shape
    h = h - h % 8
    w = w - w % 8
    img = img[:h, :w]
    result = np.zeros_like(img, dtype=np.float32)

    # å¯¹æ¯ä¸ª8x8å—è¿›è¡ŒDCTå˜æ¢å’Œé‡åŒ–
    for i in range(0, h, 8):
        for j in range(0, w, 8):
            block = img[i:i+8, j:j+8].astype(np.float32) - 128
            dct_block = fftpack.dct(fftpack.dct(block.T, norm='ortho').T, norm='ortho')
            quantized = np.round(dct_block / Q)
            dequantized = quantized * Q
            idct_block = fftpack.idct(fftpack.idct(dequantized.T, norm='ortho').T, norm='ortho')
            result[i:i+8, j:j+8] = idct_block + 128

    # è£å‰ªåˆ°æœ‰æ•ˆèŒƒå›´
    result = np.clip(result, 0, 255).astype(np.uint8)

    # è½¬æ¢ä¸ºå½©è‰²å›¾åƒ
    result = cv2.cvtColor(result, cv2.COLOR_GRAY2BGR)

    return result
```

## 4. åˆ†å½¢å‹ç¼©ï¼šè‡ªç›¸ä¼¼å‹ç¼©

åˆ†å½¢å‹ç¼©å°±åƒæ˜¯"å¯»æ‰¾å›¾åƒä¸­çš„è‡ªæˆ‘å¤åˆ¶"ï¼Œå®ƒåˆ©ç”¨å›¾åƒä¸­å­˜åœ¨çš„è‡ªç›¸ä¼¼æ€§æ¥å‹ç¼©æ•°æ®ã€‚è¿™å°±åƒæ˜¯å‘ç°å›¾åƒä¸­çš„"ä¿„ç½—æ–¯å¥—å¨ƒ"ï¼Œå¤§å›¾æ¡ˆä¸­è—ç€ç›¸ä¼¼çš„å°å›¾æ¡ˆï¼ğŸ­

### 4.1 åŸºæœ¬åŸç†

åˆ†å½¢å‹ç¼©åŸºäºè¿­ä»£å‡½æ•°ç³»ç»Ÿ(IFS)ï¼Œé€šè¿‡å¯»æ‰¾å›¾åƒä¸­çš„è‡ªç›¸ä¼¼æ€§æ¥å®ç°å‹ç¼©ã€‚è¿™å°±åƒæ˜¯æŠŠå›¾åƒåˆ†è§£æˆè®¸å¤šå°å—ï¼Œç„¶åå‘ç°è¿™äº›å°å—ä¹‹é—´å­˜åœ¨ç€ç›¸ä¼¼å…³ç³»ã€‚

æ•°å­¦è¡¨è¾¾å¼ï¼š
$$
w_i(x,y) = \begin{bmatrix} a_i & b_i \\ c_i & d_i \end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix} + \begin{bmatrix} e_i \\ f_i \end{bmatrix}
$$

å…¶ä¸­ï¼š
- $w_i$ æ˜¯ä»¿å°„å˜æ¢
- $a_i, b_i, c_i, d_i$ æ˜¯æ—‹è½¬å’Œç¼©æ”¾å‚æ•°
- $e_i, f_i$ æ˜¯å¹³ç§»å‚æ•°

#### C++å®ç°
```cpp
double fractal_compress(const Mat& src, Mat& dst, int block_size) {
    CV_Assert(!src.empty());

    // è½¬æ¢ä¸ºç°åº¦å›¾
    Mat gray;
    if (src.channels() == 3) {
        cvtColor(src, gray, COLOR_BGR2GRAY);
    } else {
        gray = src.clone();
    }

    // è°ƒæ•´å›¾åƒå¤§å°ä¸ºblock_sizeçš„å€æ•°
    int rows = ((gray.rows + block_size - 1) / block_size) * block_size;
    int cols = ((gray.cols + block_size - 1) / block_size) * block_size;
    Mat padded;
    copyMakeBorder(gray, padded, 0, rows - gray.rows, 0, cols - gray.cols, BORDER_REPLICATE);

    vector<FractalBlock> blocks;
    const int domain_step = block_size / 2;  // å®šä¹‰åŸŸå—æ­¥é•¿

    // ä½¿ç”¨OpenMPåŠ é€Ÿå—åŒ¹é…è¿‡ç¨‹
    #pragma omp parallel
    {
        vector<FractalBlock> local_blocks;

        #pragma omp for schedule(dynamic)
        for (int i = 0; i < rows; i += block_size) {
            for (int j = 0; j < cols; j += block_size) {
                Rect range_rect(j, i, block_size, block_size);
                Mat range_block = padded(range_rect);

                double best_error = numeric_limits<double>::max();
                FractalBlock best_match;
                best_match.position = Point(j, i);
                best_match.size = Size(block_size, block_size);

                // åœ¨å®šä¹‰åŸŸä¸­æœç´¢æœ€ä½³åŒ¹é…
                for (int di = 0; di < rows - block_size*2; di += domain_step) {
                    for (int dj = 0; dj < cols - block_size*2; dj += domain_step) {
                        Mat domain_block = padded(Rect(dj, di, block_size*2, block_size*2));
                        Mat domain_small;
                        resize(domain_block, domain_small, Size(block_size, block_size));

                        double domain_mean, range_mean;
                        double domain_var, range_var;
                        compute_block_statistics(domain_small, domain_mean, domain_var);
                        compute_block_statistics(range_block, range_mean, range_var);

                        if (domain_var < 1e-6) continue;  // è·³è¿‡å¹³å¦åŒºåŸŸ

                        // è®¡ç®—ç¼©æ”¾å’Œåç§»ç³»æ•°
                        double scale = sqrt(range_var / domain_var);
                        double offset = range_mean - scale * domain_mean;

                        // è®¡ç®—è¯¯å·®
                        Mat predicted = domain_small * scale + offset;
                        Mat diff = predicted - range_block;
                        double error = norm(diff, NORM_L2SQR) / (block_size * block_size);

                        if (error < best_error) {
                            best_error = error;
                            best_match.scale = scale;
                            best_match.offset = offset;
                            best_match.domain_pos = Point(dj, di);
                        }
                    }
                }

                #pragma omp critical
                blocks.push_back(best_match);
            }
        }
    }

    // é‡æ„å›¾åƒ
    dst = Mat::zeros(padded.size(), CV_8UC1);
    for (const auto& block : blocks) {
        Mat domain_block = padded(Rect(block.domain_pos.x, block.domain_pos.y,
                                     block_size*2, block_size*2));
        Mat domain_small;
        resize(domain_block, domain_small, block.size);

        Mat range_block = domain_small * block.scale + block.offset;
        range_block.copyTo(dst(Rect(block.position.x, block.position.y,
                               block.size.width, block.size.height)));
    }

    // è£å‰ªå›åŸå§‹å¤§å°
    dst = dst(Rect(0, 0, src.cols, src.rows));

    // è®¡ç®—å‹ç¼©ç‡ï¼ˆæ¯ä¸ªå—å­˜å‚¨5ä¸ªdoubleï¼šä½ç½®x,yï¼Œscaleï¼Œoffsetï¼Œdomain_pos x,yï¼‰
    size_t compressed_size = blocks.size() * (sizeof(double) * 5);
    return compute_compression_ratio(src.total(), compressed_size);
}
```

#### Pythonå®ç°
```python
def fractal_compression(img_path, block_size=8):
    """
    é—®é¢˜49ï¼šåˆ†å½¢å‹ç¼©
    ä½¿ç”¨åˆ†å½¢ç†è®ºè¿›è¡Œå›¾åƒå‹ç¼©ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰

    å‚æ•°:
        img_path: è¾“å…¥å›¾åƒè·¯å¾„
        block_size: åˆ†å—å¤§å°ï¼Œé»˜è®¤ä¸º8

    è¿”å›:
        å‹ç¼©åé‡å»ºçš„å›¾åƒ
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        raise ValueError(f"æ— æ³•è¯»å–å›¾åƒ: {img_path}")

    # ç¡®ä¿å›¾åƒå°ºå¯¸æ˜¯block_sizeçš„æ•´æ•°å€
    h, w = img.shape
    h = h - h % block_size
    w = w - w % block_size
    img = img[:h, :w]
    result = np.zeros_like(img)

    # å¯¹æ¯ä¸ªå—è¿›è¡Œå¤„ç†
    for i in range(0, h, block_size):
        for j in range(0, w, block_size):
            block = img[i:i+block_size, j:j+block_size]
            # ç®€åŒ–çš„åˆ†å½¢å˜æ¢ï¼šä½¿ç”¨å‡å€¼å’Œæ–¹å·®è¿›è¡Œç¼–ç 
            mean = np.mean(block)
            std = np.std(block)
            # é‡å»ºï¼šä½¿ç”¨ç»Ÿè®¡ç‰¹å¾é‡å»ºå—
            result[i:i+block_size, j:j+block_size] = np.clip(
                mean + (block - mean) * (std / (std + 1e-6)), 0, 255)

    # è½¬æ¢ä¸ºå½©è‰²å›¾åƒ
    result = cv2.cvtColor(result.astype(np.uint8), cv2.COLOR_GRAY2BGR)

    return result
```

### 4.2 è§£ç è¿‡ç¨‹

è§£ç è¿‡ç¨‹å°±åƒæ˜¯"ä»ç§å­ç”Ÿé•¿å‡ºå›¾åƒ"ï¼Œé€šè¿‡åå¤åº”ç”¨å˜æ¢æ¥é‡å»ºå›¾åƒã€‚è¿™å°±åƒæ˜¯æŠŠä¸€ä¸ªå°å›¾æ¡ˆä¸æ–­å¤åˆ¶ã€å˜æ¢ï¼Œæœ€ç»ˆå¾—åˆ°å®Œæ•´çš„å›¾åƒï¼

#### C++å®ç°
```cpp
void FractalCompressor::decompress(Mat& dst, int iterations) {
    // åˆå§‹åŒ–éšæœºå›¾åƒ
    dst = Mat::zeros(range_size, range_size, CV_8UC1);
    randn(dst, 128, 50);

    // è¿­ä»£åº”ç”¨å˜æ¢
    for (int iter = 0; iter < iterations; iter++) {
        Mat next = Mat::zeros(dst.size(), CV_8UC1);

        for (int i = 0; i < transforms.size(); i++) {
            const auto& transform = transforms[i];
            Mat transformed;
            apply_transform(dst, transformed, transform);

            // åº”ç”¨å¯¹æ¯”åº¦å’Œäº®åº¦
            transformed = transform.contrast * transformed + transform.brightness;

            // å¤åˆ¶åˆ°å¯¹åº”ä½ç½®
            int row = (i / (dst.cols/range_size)) * range_size;
            int col = (i % (dst.cols/range_size)) * range_size;
            transformed.copyTo(next(Rect(col, row, range_size, range_size)));
        }

        dst = next;
    }
}
```

#### Pythonå®ç°
```python
def decompress(self, iterations=10):
    """è§£å‹ç¼©å›¾åƒ"""
    # åˆå§‹åŒ–éšæœºå›¾åƒ
    img = np.random.normal(128, 50, (self.range_size, self.range_size))

    # è¿­ä»£åº”ç”¨å˜æ¢
    for _ in range(iterations):
        next_img = np.zeros_like(img)

        for i, transform in enumerate(self.transforms):
            # åº”ç”¨ä»¿å°„å˜æ¢
            transformed = self.apply_transform(img, transform['matrix'])

            # åº”ç”¨å¯¹æ¯”åº¦å’Œäº®åº¦
            transformed = transform['contrast'] * transformed + transform['brightness']

            # å¤åˆ¶åˆ°å¯¹åº”ä½ç½®
            row = (i // (img.shape[1]//self.range_size)) * self.range_size
            col = (i % (img.shape[1]//self.range_size)) * self.range_size
            next_img[row:row+self.range_size, col:col+self.range_size] = transformed

        img = next_img

    return img
```

## 5. å°æ³¢å‹ç¼©ï¼šå¤šå°ºåº¦å‹ç¼©

å°æ³¢å‹ç¼©å°±åƒæ˜¯"å¤šå±‚æ¬¡çš„ç²¾ç»†å‹ç¼©"ï¼Œå®ƒåˆ©ç”¨å°æ³¢å˜æ¢æ¥å‹ç¼©æ•°æ®ã€‚è¿™å°±åƒæ˜¯æŠŠå›¾åƒåˆ†è§£æˆä¸åŒé¢‘ç‡çš„å°æ³¢ï¼Œé«˜é¢‘éƒ¨åˆ†ä»£è¡¨ç»†èŠ‚ï¼Œä½é¢‘éƒ¨åˆ†ä»£è¡¨æ•´ä½“è½®å»“ã€‚

æ•°å­¦è¡¨è¾¾å¼ï¼š
$$
\psi(t) = \sum_{k=-\infty}^{\infty} h[k] \psi(2t-k)
$$

å…¶ä¸­ï¼š
- $\psi(t)$ æ˜¯å°æ³¢å‡½æ•°
- $h[k]$ æ˜¯æ»¤æ³¢å™¨ç³»æ•°

#### C++å®ç°
```cpp
double wavelet_compress(const Mat& src, Mat& dst, int level, double threshold) {
    CV_Assert(!src.empty());

    // è½¬æ¢ä¸ºç°åº¦å›¾å¹¶è½¬æ¢ä¸ºæµ®ç‚¹å‹
    Mat gray;
    if (src.channels() == 3) {
        cvtColor(src, gray, COLOR_BGR2GRAY);
    } else {
        gray = src.clone();
    }
    Mat float_img;
    gray.convertTo(float_img, CV_64F);

    // ç¡®ä¿å›¾åƒå°ºå¯¸æ˜¯2çš„å¹‚æ¬¡
    int max_dim = max(float_img.rows, float_img.cols);
    int pad_size = 1;
    while (pad_size < max_dim) pad_size *= 2;

    Mat padded;
    copyMakeBorder(float_img, padded, 0, pad_size - float_img.rows,
                   0, pad_size - float_img.cols, BORDER_REFLECT);

    int rows = padded.rows;
    int cols = padded.cols;
    Mat temp = padded.clone();

    // å‰å‘å°æ³¢å˜æ¢
    for (int l = 0; l < level; l++) {
        // æ°´å¹³æ–¹å‘å˜æ¢
        #pragma omp parallel for
        for (int i = 0; i < rows; i++) {
            vector<double> row(cols);
            for (int j = 0; j < cols; j++) {
                row[j] = temp.at<double>(i, j);
            }
            wavelet_transform_1d(row);
            for (int j = 0; j < cols; j++) {
                temp.at<double>(i, j) = row[j];
            }
        }

        // å‚ç›´æ–¹å‘å˜æ¢
        #pragma omp parallel for
        for (int j = 0; j < cols; j++) {
            vector<double> col(rows);
            for (int i = 0; i < rows; i++) {
                col[i] = temp.at<double>(i, j);
            }
            wavelet_transform_1d(col);
            for (int i = 0; i < rows; i++) {
                temp.at<double>(i, j) = col[i];
            }
        }

        rows /= 2;
        cols /= 2;
    }

    // é˜ˆå€¼å¤„ç†
    double max_coef = 0;
    for (int i = 0; i < temp.rows; i++) {
        for (int j = 0; j < temp.cols; j++) {
            max_coef = max(max_coef, abs(temp.at<double>(i, j)));
        }
    }

    double thresh = max_coef * threshold / 100.0;
    int nonzero_count = 0;

    #pragma omp parallel for reduction(+:nonzero_count)
    for (int i = 0; i < temp.rows; i++) {
        for (int j = 0; j < temp.cols; j++) {
            double& val = temp.at<double>(i, j);
            if (abs(val) < thresh) {
                val = 0;
            } else {
                nonzero_count++;
            }
        }
    }

    // åå‘å°æ³¢å˜æ¢
    rows = temp.rows;
    cols = temp.cols;
    for (int l = level - 1; l >= 0; l--) {
        rows = temp.rows >> l;
        cols = temp.cols >> l;

        // å‚ç›´æ–¹å‘é€†å˜æ¢
        #pragma omp parallel for
        for (int j = 0; j < cols; j++) {
            vector<double> col(rows);
            for (int i = 0; i < rows; i++) {
                col[i] = temp.at<double>(i, j);
            }
            wavelet_transform_1d(col, true);
            for (int i = 0; i < rows; i++) {
                temp.at<double>(i, j) = col[i];
            }
        }

        // æ°´å¹³æ–¹å‘é€†å˜æ¢
        #pragma omp parallel for
        for (int i = 0; i < rows; i++) {
            vector<double> row(cols);
            for (int j = 0; j < cols; j++) {
                row[j] = temp.at<double>(i, j);
            }
            wavelet_transform_1d(row, true);
            for (int j = 0; j < cols; j++) {
                temp.at<double>(i, j) = row[j];
            }
        }
    }

    // è£å‰ªå›åŸå§‹å¤§å°å¹¶è½¬æ¢å›8ä½å›¾åƒ
    Mat result = temp(Rect(0, 0, src.cols, src.rows));
    normalize(result, result, 0, 255, NORM_MINMAX);
    result.convertTo(dst, CV_8UC1);

    // è®¡ç®—å‹ç¼©ç‡ï¼ˆåªå­˜å‚¨éé›¶ç³»æ•°ï¼‰
    size_t compressed_size = nonzero_count * (sizeof(double) + sizeof(int) * 2);  // å€¼å’Œä½ç½®
    return compute_compression_ratio(src.total(), compressed_size);
}
```

#### Pythonå®ç°
```python
def wavelet_compression(img_path, threshold=10):
    """
    é—®é¢˜50ï¼šå°æ³¢å‹ç¼©
    ä½¿ç”¨å°æ³¢å˜æ¢è¿›è¡Œå›¾åƒå‹ç¼©

    å‚æ•°:
        img_path: è¾“å…¥å›¾åƒè·¯å¾„
        threshold: ç³»æ•°é˜ˆå€¼ï¼Œé»˜è®¤ä¸º10

    è¿”å›:
        å‹ç¼©åé‡å»ºçš„å›¾åƒ
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        raise ValueError(f"æ— æ³•è¯»å–å›¾åƒ: {img_path}")

    # è¿›è¡Œå°æ³¢å˜æ¢
    coeffs = pywt.wavedec2(img, 'haar', level=3)

    # é˜ˆå€¼å¤„ç†
    for i in range(1, len(coeffs)):
        for detail in coeffs[i]:
            detail[np.abs(detail) < threshold] = 0

    # é‡å»ºå›¾åƒ
    result = pywt.waverec2(coeffs, 'haar')

    # è£å‰ªåˆ°åŸå§‹å°ºå¯¸
    result = result[:img.shape[0], :img.shape[1]]

    # å½’ä¸€åŒ–åˆ°0-255
    result = np.clip(result, 0, 255).astype(np.uint8)

    # è½¬æ¢ä¸ºå½©è‰²å›¾åƒ
    result = cv2.cvtColor(result, cv2.COLOR_GRAY2BGR)

    return result
```

## 6. å®é™…åº”ç”¨ä¸æ³¨æ„äº‹é¡¹

### 6.1 åº”ç”¨åœºæ™¯ ğŸ¯

1. ç½‘é¡µå›¾ç‰‡ä¼˜åŒ–
   - åŠ å¿«åŠ è½½é€Ÿåº¦
   - èŠ‚çœå¸¦å®½
   - æå‡ç”¨æˆ·ä½“éªŒ

2. ç§»åŠ¨åº”ç”¨å›¾ç‰‡å¤„ç†
   - èŠ‚çœå­˜å‚¨ç©ºé—´
   - ä¼˜åŒ–å†…å­˜å ç”¨
   - æå‡åº”ç”¨æ€§èƒ½

3. åŒ»å­¦å›¾åƒå‹ç¼©
   - ä¿è¯å›¾åƒè´¨é‡
   - å‡å°‘å­˜å‚¨æˆæœ¬
   - åŠ å¿«ä¼ è¾“é€Ÿåº¦

### 6.2 æ€§èƒ½ä¼˜åŒ–å»ºè®® ğŸ’ª

1. ç®—æ³•é€‰æ‹©
   - æ ¹æ®å®é™…éœ€æ±‚é€‰æ‹©åˆé€‚çš„å‹ç¼©æ–¹æ³•
   - è€ƒè™‘å‹ç¼©ç‡å’Œè´¨é‡å¹³è¡¡
   - æƒè¡¡å¤„ç†é€Ÿåº¦å’Œå‹ç¼©æ•ˆæœ

2. å®ç°æŠ€å·§
   - ä½¿ç”¨å¹¶è¡Œè®¡ç®—åŠ é€Ÿå¤„ç†
   - ä¼˜åŒ–å†…å­˜ä½¿ç”¨
   - é¿å…é‡å¤è®¡ç®—

3. æ³¨æ„äº‹é¡¹
   - æ§åˆ¶å‹ç¼©è´¨é‡
   - è€ƒè™‘å›¾åƒç±»å‹
   - æ³¨æ„å‹ç¼©å‚æ•°è®¾ç½®

## 7. æ€§èƒ½è¯„ä¼°ä¸å¯¹æ¯”

### 7.1 å‹ç¼©æ•ˆæœå¯¹æ¯” ğŸ“Š

| ç®—æ³• | å‹ç¼©ç‡ | è´¨é‡æŸå¤± | å¤„ç†é€Ÿåº¦ | é€‚ç”¨åœºæ™¯ |
|------|--------|----------|----------|----------|
| RLE | 2:1 | æ—  | å¿« | ç®€å•å›¾åƒï¼Œé‡å¤å›¾æ¡ˆå¤š |
| JPEG | 10:1 | ä¸­ç­‰ | å¿« | è‡ªç„¶å›¾åƒï¼Œç…§ç‰‡ |
| åˆ†å½¢ | 20:1 | è¾ƒå¤§ | æ…¢ | çº¹ç†å›¾åƒï¼Œè‰ºæœ¯å›¾ç‰‡ |
| å°æ³¢ | 15:1 | å° | ä¸­ç­‰ | åŒ»å­¦å›¾åƒï¼Œé«˜è´¨é‡éœ€æ±‚ |

### 7.2 è´¨é‡è¯„ä¼°æŒ‡æ ‡ ğŸ“ˆ

1. å®¢è§‚æŒ‡æ ‡
   - PSNR (å³°å€¼ä¿¡å™ªæ¯”): è¡¡é‡å›¾åƒè´¨é‡
   - SSIM (ç»“æ„ç›¸ä¼¼æ€§): è¯„ä¼°è§†è§‰è´¨é‡
   - å‹ç¼©æ¯”: è¡¡é‡å‹ç¼©æ•ˆç‡

2. ä¸»è§‚è¯„ä¼°
   - è§†è§‰æ•ˆæœ
   - ç»†èŠ‚ä¿ç•™
   - è¾¹ç¼˜æ¸…æ™°åº¦

### 7.3 æ€§èƒ½å»ºè®® ğŸ’¡

1. å›¾ç‰‡åˆ†äº«ç±»åº”ç”¨
   - æ¨è: JPEGå‹ç¼©
   - å‹ç¼©ç‡: 8:1 ~ 12:1
   - è´¨é‡å‚æ•°: 75-85

2. åŒ»å­¦å½±åƒå­˜å‚¨
   - æ¨è: æ— æŸå‹ç¼©æˆ–å°æ³¢å‹ç¼©
   - å‹ç¼©ç‡: 2:1 ~ 4:1
   - ä¿è¯è¯Šæ–­è´¨é‡

3. è‰ºæœ¯å›¾ç‰‡å¤„ç†
   - æ¨è: åˆ†å½¢å‹ç¼©
   - å‹ç¼©ç‡: 15:1 ~ 25:1
   - ä¿ç•™çº¹ç†ç‰¹å¾

## 8. æ€»ç»“

å›¾åƒå‹ç¼©å°±åƒæ˜¯æ•°å­—ä¸–ç•Œçš„"ç©ºé—´ç®¡ç†å¤§å¸ˆ"ï¼Œé€šè¿‡ä¸åŒçš„å‹ç¼©æŠ€æœ¯ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä¿æŒå›¾åƒè´¨é‡çš„åŒæ—¶æœ‰æ•ˆå‡å°æ–‡ä»¶å¤§å°ã€‚ä»æ— æŸå‹ç¼©çš„å®Œç¾ä¿çœŸï¼Œåˆ°JPEGçš„æ™ºèƒ½å‹ç¼©ï¼Œå†åˆ°åˆ†å½¢å‹ç¼©çš„è‡ªç›¸ä¼¼æ€§åˆ©ç”¨ï¼Œæ¯ç§æ–¹æ³•éƒ½æœ‰å…¶ç‹¬ç‰¹çš„ä¼˜åŠ¿å’Œåº”ç”¨åœºæ™¯ã€‚ğŸ¯

### 8.1 ç®—æ³•å¯¹æ¯”

| ç®—æ³• | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|----------|
| RLE | å®ç°ç®€å•ï¼Œæ— æŸå‹ç¼© | å‹ç¼©ç‡ä½ | ç®€å•å›¾åƒï¼Œé‡å¤å›¾æ¡ˆå¤š |
| JPEG | å‹ç¼©ç‡é«˜ï¼Œå¤„ç†å¿« | æœ‰æŸå‹ç¼©ï¼Œå—æ•ˆåº” | ç…§ç‰‡ï¼Œç½‘é¡µå›¾ç‰‡ |
| åˆ†å½¢ | å‹ç¼©ç‡æé«˜ | å‹ç¼©æ…¢ï¼Œè´¨é‡æŸå¤±å¤§ | è‡ªç„¶å›¾åƒï¼Œçº¹ç†ä¸°å¯Œ |
| å°æ³¢ | å¤šå°ºåº¦åˆ†æï¼Œè´¨é‡å¥½ | è®¡ç®—å¤æ‚ | åŒ»å­¦å›¾åƒï¼Œéœ€è¦é«˜è´¨é‡ |

> ğŸ’¡ å°è´´å£«ï¼šåœ¨å®é™…åº”ç”¨ä¸­ï¼Œå»ºè®®æ ¹æ®å…·ä½“éœ€æ±‚é€‰æ‹©åˆé€‚çš„å‹ç¼©ç®—æ³•ã€‚å¯¹äºç½‘é¡µå›¾ç‰‡ï¼ŒJPEGæ˜¯ä¸é”™çš„é€‰æ‹©ï¼›å¯¹äºåŒ»å­¦å›¾åƒï¼Œå¯ä»¥è€ƒè™‘æ— æŸå‹ç¼©æˆ–å°æ³¢å‹ç¼©ï¼›å¯¹äºè‰ºæœ¯å›¾ç‰‡ï¼Œåˆ†å½¢å‹ç¼©å¯èƒ½ä¼šå¸¦æ¥æ„æƒ³ä¸åˆ°çš„æ•ˆæœã€‚è®°ä½ï¼Œæ²¡æœ‰æœ€å¥½çš„å‹ç¼©ç®—æ³•ï¼Œåªæœ‰æœ€é€‚åˆçš„ç®—æ³•ï¼

## å‚è€ƒèµ„æ–™

1. Sayood K. Introduction to data compression[M]. Morgan Kaufmann, 2017
2. Wallace G K. The JPEG still picture compression standard[J]. IEEE transactions on consumer electronics, 1992
3. Barnsley M F, et al. The science of fractal images[M]. Springer, 1988
4. Mallat S G. A theory for multiresolution signal decomposition[J]. TPAMI, 1989
5. OpenCVå®˜æ–¹æ–‡æ¡£: https://docs.opencv.org/
6. æ›´å¤šèµ„æº: [IP101é¡¹ç›®ä¸»é¡µ](https://github.com/GlimmerLab/IP101)