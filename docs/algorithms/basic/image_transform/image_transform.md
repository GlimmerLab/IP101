# ğŸŒŸ å›¾åƒå˜æ¢é­”æ³•æŒ‡å—

> ğŸ¨ åœ¨å›¾åƒå¤„ç†çš„ä¸–ç•Œé‡Œï¼Œå˜æ¢å°±åƒæ˜¯ç»™å›¾ç‰‡åš"ç‘œä¼½"ï¼Œè®©å®ƒèƒ½å¤Ÿè‡ªç”±åœ°ä¼¸å±•å’Œå˜å½¢ã€‚è®©æˆ‘ä»¬ä¸€èµ·æ¥æ¢ç´¢è¿™äº›ç¥å¥‡çš„å˜æ¢æœ¯å§ï¼

## ğŸ“š ç›®å½•

1. [åŸºç¡€æ¦‚å¿µ - å˜æ¢çš„"é­”æ³•åŸºçŸ³"](#åŸºç¡€æ¦‚å¿µ)
2. [ä»¿å°„å˜æ¢ - å›¾åƒçš„"ç‘œä¼½å¤§å¸ˆ"](#ä»¿å°„å˜æ¢)
3. [é€è§†å˜æ¢ - ç©ºé—´çš„"é­”æ³•å¸ˆ"](#é€è§†å˜æ¢)
4. [æ—‹è½¬å˜æ¢ - å›¾åƒçš„"èŠ­è•¾èˆ"](#æ—‹è½¬å˜æ¢)
5. [ç¼©æ”¾å˜æ¢ - å°ºå¯¸çš„"é­”æ³•è¯æ°´"](#ç¼©æ”¾å˜æ¢)
6. [å¹³ç§»å˜æ¢ - ä½ç½®çš„"æ•£æ­¥è¾¾äºº"](#å¹³ç§»å˜æ¢)
7. [é•œåƒå˜æ¢ - å›¾åƒçš„"é­”é•œé­”é•œ"](#é•œåƒå˜æ¢)
8. [æ€§èƒ½ä¼˜åŒ– - å˜æ¢çš„"åŠ é€Ÿæœ¯"](#æ€§èƒ½ä¼˜åŒ–æŒ‡å—)

## åŸºç¡€æ¦‚å¿µ

### ä»€ä¹ˆæ˜¯å›¾åƒå˜æ¢ï¼ŸğŸ¤”

å›¾åƒå˜æ¢å°±åƒæ˜¯ç»™å›¾ç‰‡åš"ç‘œä¼½"ï¼Œé€šè¿‡æ•°å­¦é­”æ³•æ”¹å˜å›¾ç‰‡çš„å½¢çŠ¶ã€å¤§å°æˆ–ä½ç½®ã€‚åœ¨è®¡ç®—æœºçš„ä¸–ç•Œé‡Œï¼Œè¿™ç§å˜æ¢å¯ä»¥ç”¨çŸ©é˜µæ¥è¡¨ç¤ºï¼š

$$
\begin{bmatrix} x' \\ y' \\ 1 \end{bmatrix} =
\begin{bmatrix}
a_{11} & a_{12} & t_x \\
a_{21} & a_{22} & t_y \\
0 & 0 & 1
\end{bmatrix}
\begin{bmatrix} x \\ y \\ 1 \end{bmatrix}
$$

è¿™ä¸ªçœ‹èµ·æ¥å¾ˆ"å“äºº"çš„å…¬å¼å…¶å®å¾ˆç®€å•ï¼š
- $(x, y)$ æ˜¯åŸå§‹ç‚¹çš„ä½ç½®
- $(x', y')$ æ˜¯å˜æ¢åçš„ä½ç½®
- ä¸­é—´çš„çŸ©é˜µå°±æ˜¯æˆ‘ä»¬çš„"é­”æ³•é…æ–¹"

### å˜æ¢çš„åŸºæœ¬åŸç† ğŸ“

æ‰€æœ‰çš„å˜æ¢éƒ½éµå¾ªä¸€ä¸ªåŸºæœ¬åŸåˆ™ï¼š
1. æ‰¾åˆ°åŸå§‹ç‚¹çš„åæ ‡
2. åº”ç”¨å˜æ¢çŸ©é˜µ
3. å¾—åˆ°æ–°çš„åæ ‡

å°±åƒçƒ¹é¥ªä¸€æ ·ï¼šåŸæ–™ â†’ é…æ–¹ â†’ ç¾é£Ÿï¼

## ä»¿å°„å˜æ¢

### ç†è®ºåŸºç¡€ ğŸ“

ä»¿å°„å˜æ¢æ˜¯æœ€åŸºç¡€çš„"é­”æ³•"ä¹‹ä¸€ï¼Œå®ƒèƒ½ä¿æŒå¹³è¡Œçº¿ä¾ç„¶å¹³è¡Œï¼ˆå°±æ˜¯è¿™ä¹ˆå›ºæ‰§ï¼ï¼‰ã€‚å…¶æ ¸å¿ƒå…¬å¼æ˜¯ï¼š

$$
\begin{pmatrix} x' \\ y' \end{pmatrix} =
\begin{pmatrix}
a & b \\
c & d
\end{pmatrix}
\begin{pmatrix} x \\ y \end{pmatrix} +
\begin{pmatrix} t_x \\ t_y \end{pmatrix}
$$

### æ‰‹åŠ¨å®ç° ğŸ’»

```python
def affine_transform(img_path, src_points, dst_points):
    """
    ä»¿å°„å˜æ¢ï¼šå›¾åƒç•Œçš„"ç‘œä¼½å¤§å¸ˆ"

    å‚æ•°:
        img_path: è¾“å…¥å›¾åƒè·¯å¾„
        src_points: æºå›¾åƒä¸­çš„ä¸‰ä¸ªç‚¹åæ ‡ï¼Œå½¢çŠ¶ä¸º(3, 2)
        dst_points: ç›®æ ‡å›¾åƒä¸­çš„ä¸‰ä¸ªç‚¹åæ ‡ï¼Œå½¢çŠ¶ä¸º(3, 2)

    è¿”å›:
        å˜æ¢åçš„å›¾åƒ
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path)
    if img is None:
        raise ValueError(f"æ— æ³•è¯»å–å›¾åƒ: {img_path}")

    # è·å–å›¾åƒå°ºå¯¸
    h, w = img.shape[:2]

    # è®¡ç®—ä»¿å°„å˜æ¢çŸ©é˜µ
    M = cv2.getAffineTransform(src_points, dst_points)

    # åˆ›å»ºè¾“å‡ºå›¾åƒ
    result = np.zeros_like(img)

    # æ‰‹åŠ¨å®ç°ä»¿å°„å˜æ¢
    for y in range(h):
        for x in range(w):
            # è®¡ç®—æºå›¾åƒä¸­çš„å¯¹åº”ç‚¹
            src_x = int(M[0, 0] * x + M[0, 1] * y + M[0, 2])
            src_y = int(M[1, 0] * x + M[1, 1] * y + M[1, 2])

            # æ£€æŸ¥æºç‚¹æ˜¯å¦åœ¨å›¾åƒèŒƒå›´å†…
            if 0 <= src_x < w and 0 <= src_y < h:
                result[y, x] = img[src_y, src_x]

    return result
```

### æ€§èƒ½ä¼˜åŒ– ğŸš€

ä¸ºäº†è®©å˜æ¢æ›´å¿«ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨SIMDï¼ˆå•æŒ‡ä»¤å¤šæ•°æ®ï¼‰æŠ€æœ¯å’ŒåŒçº¿æ€§æ’å€¼ï¼š

```cpp
Mat affine_transform(const Mat& src, const Mat& M, const Size& size) {
    Mat dst(size, src.type());

    // è·å–å˜æ¢çŸ©é˜µçš„å…ƒç´ 
    float m00 = M.at<float>(0,0);
    float m01 = M.at<float>(0,1);
    float m02 = M.at<float>(0,2);
    float m10 = M.at<float>(1,0);
    float m11 = M.at<float>(1,1);
    float m12 = M.at<float>(1,2);

    #pragma omp parallel for
    for(int y = 0; y < dst.rows; y++) {
        for(int x = 0; x < dst.cols; x++) {
            // è®¡ç®—æºå›¾åƒåæ ‡
            float src_x = m00 * x + m01 * y + m02;
            float src_y = m10 * x + m11 * y + m12;

            // è¾¹ç•Œæ£€æŸ¥
            if(src_x >= 0 && src_x < src.cols-1 &&
               src_y >= 0 && src_y < src.rows-1) {
                if(src.type() == CV_8UC3) {
                    Vec3b p = bilinear_interpolation<Vec3b>(src, src_x, src_y);
                    dst.at<Vec3b>(y,x) = p;
                } else {
                    uchar p = bilinear_interpolation<uchar>(src, src_x, src_y);
                    dst.at<uchar>(y,x) = p;
                }
            }
        }
    }

    return dst;
}
```

## é€è§†å˜æ¢

### ç†è®ºåŸºç¡€ ğŸ“š

é€è§†å˜æ¢å°±åƒç»™å›¾ç‰‡æˆ´ä¸Šäº†3Dçœ¼é•œï¼Œå¯ä»¥æ¨¡æ‹ŸçœŸå®ä¸–ç•Œçš„è§†è§’æ•ˆæœã€‚å…¶æ•°å­¦è¡¨è¾¾å¼æ˜¯ï¼š

$$
\begin{bmatrix} x' \\ y' \\ w \end{bmatrix} =
\begin{bmatrix}
h_{11} & h_{12} & h_{13} \\
h_{21} & h_{22} & h_{23} \\
h_{31} & h_{32} & h_{33}
\end{bmatrix}
\begin{bmatrix} x \\ y \\ 1 \end{bmatrix}
$$

æœ€ç»ˆåæ ‡ï¼š$(x'/w, y'/w)$

### æ‰‹åŠ¨å®ç° ğŸ’»

```python
def perspective_transform(img_path, src_points, dst_points):
    """
    é€è§†å˜æ¢ï¼šå›¾åƒç•Œçš„"3Dé­”æ³•å¸ˆ"

    å‚æ•°:
        img_path: è¾“å…¥å›¾åƒè·¯å¾„
        src_points: æºå›¾åƒä¸­çš„å››ä¸ªç‚¹åæ ‡ï¼Œå½¢çŠ¶ä¸º(4, 2)
        dst_points: ç›®æ ‡å›¾åƒä¸­çš„å››ä¸ªç‚¹åæ ‡ï¼Œå½¢çŠ¶ä¸º(4, 2)

    è¿”å›:
        å˜æ¢åçš„å›¾åƒ
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path)
    if img is None:
        raise ValueError(f"æ— æ³•è¯»å–å›¾åƒ: {img_path}")

    # è·å–å›¾åƒå°ºå¯¸
    h, w = img.shape[:2]

    # è®¡ç®—é€è§†å˜æ¢çŸ©é˜µ
    M = cv2.getPerspectiveTransform(src_points, dst_points)

    # åˆ›å»ºè¾“å‡ºå›¾åƒ
    result = np.zeros_like(img)

    # æ‰‹åŠ¨å®ç°é€è§†å˜æ¢
    for y in range(h):
        for x in range(w):
            # è®¡ç®—æºå›¾åƒä¸­çš„å¯¹åº”ç‚¹
            denominator = M[2, 0] * x + M[2, 1] * y + M[2, 2]
            if denominator != 0:
                src_x = int((M[0, 0] * x + M[0, 1] * y + M[0, 2]) / denominator)
                src_y = int((M[1, 0] * x + M[1, 1] * y + M[1, 2]) / denominator)

                # æ£€æŸ¥æºç‚¹æ˜¯å¦åœ¨å›¾åƒèŒƒå›´å†…
                if 0 <= src_x < w and 0 <= src_y < h:
                    result[y, x] = img[src_y, src_x]

    return result
```

### æ€§èƒ½ä¼˜åŒ– ğŸš€

ä½¿ç”¨SIMDå’Œå¤šçº¿ç¨‹ä¼˜åŒ–é€è§†å˜æ¢ï¼š

```cpp
Mat perspective_transform(const Mat& src, const Mat& M, const Size& size) {
    Mat dst(size, src.type());

    // è·å–å˜æ¢çŸ©é˜µçš„å…ƒç´ 
    float m00 = M.at<float>(0,0);
    float m01 = M.at<float>(0,1);
    float m02 = M.at<float>(0,2);
    float m10 = M.at<float>(1,0);
    float m11 = M.at<float>(1,1);
    float m12 = M.at<float>(1,2);
    float m20 = M.at<float>(2,0);
    float m21 = M.at<float>(2,1);
    float m22 = M.at<float>(2,2);

    #pragma omp parallel for
    for(int y = 0; y < dst.rows; y++) {
        for(int x = 0; x < dst.cols; x++) {
            // è®¡ç®—æºå›¾åƒåæ ‡
            float denominator = m20 * x + m21 * y + m22;
            float src_x = (m00 * x + m01 * y + m02) / denominator;
            float src_y = (m10 * x + m11 * y + m12) / denominator;

            // è¾¹ç•Œæ£€æŸ¥
            if(src_x >= 0 && src_x < src.cols-1 &&
               src_y >= 0 && src_y < src.rows-1) {
                if(src.type() == CV_8UC3) {
                    Vec3b p = bilinear_interpolation<Vec3b>(src, src_x, src_y);
                    dst.at<Vec3b>(y,x) = p;
                } else {
                    uchar p = bilinear_interpolation<uchar>(src, src_x, src_y);
                    dst.at<uchar>(y,x) = p;
                }
            }
        }
    }

    return dst;
}
```

### å®æˆ˜å°è´´å£« ğŸŒŸ

1. é€‰æ‹©å››ä¸ªç‰¹å¾ç‚¹æ—¶è¦å°½é‡åˆ†æ•£
2. æ³¨æ„å¤„ç†é€è§†é™¤æ•°ä¸º0çš„æƒ…å†µ
3. å¯ä»¥ç”¨æ¥å®ç°ï¼š
   - æ–‡æ¡£æ‰«æçŸ«æ­£
   - è½¦ç‰Œè¯†åˆ«é¢„å¤„ç†
   - å¹¿å‘Šç‰Œé€è§†æ ¡æ­£

## æ—‹è½¬å˜æ¢

### ç†è®ºåŸºç¡€ ğŸ­

æ—‹è½¬å˜æ¢å°±åƒè®©å›¾ç‰‡è·³èŠ­è•¾ï¼Œä¼˜é›…åœ°è½¬åœˆåœˆã€‚æ—‹è½¬çŸ©é˜µæ˜¯è¿™æ ·çš„ï¼š

$$
R(\theta) = \begin{bmatrix}
\cos\theta & -\sin\theta \\
\sin\theta & \cos\theta
\end{bmatrix}
$$

è€ƒè™‘æ—‹è½¬ä¸­å¿ƒç‚¹$(c_x, c_y)$ï¼Œå®Œæ•´çš„å˜æ¢çŸ©é˜µæ˜¯ï¼š

$$
\begin{bmatrix}
\cos\theta & -\sin\theta & c_x(1-\cos\theta) + c_y\sin\theta \\
\sin\theta & \cos\theta & c_y(1-\cos\theta) - c_x\sin\theta \\
0 & 0 & 1
\end{bmatrix}
$$

### æ‰‹åŠ¨å®ç° ğŸ’ƒ

```python
def rotate_image(img_path, angle, center=None):
    """
    æ—‹è½¬å˜æ¢ï¼šå›¾åƒç•Œçš„"èŠ­è•¾èˆè€…"
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path)
    if img is None:
        raise ValueError(f"æ— æ³•è¯»å–å›¾åƒ: {img_path}")

    # è·å–å›¾åƒå°ºå¯¸
    h, w = img.shape[:2]

    # å¦‚æœæœªæŒ‡å®šæ—‹è½¬ä¸­å¿ƒï¼Œåˆ™ä½¿ç”¨å›¾åƒä¸­å¿ƒ
    if center is None:
        center = (w // 2, h // 2)

    # è®¡ç®—æ—‹è½¬çŸ©é˜µ
    M = cv2.getRotationMatrix2D(center, angle, 1.0)

    # åˆ›å»ºè¾“å‡ºå›¾åƒ
    result = np.zeros_like(img)

    # æ‰‹åŠ¨å®ç°æ—‹è½¬
    for y in range(h):
        for x in range(w):
            # è®¡ç®—æºå›¾åƒä¸­çš„å¯¹åº”ç‚¹
            src_x = int(M[0, 0] * x + M[0, 1] * y + M[0, 2])
            src_y = int(M[1, 0] * x + M[1, 1] * y + M[1, 2])

            # æ£€æŸ¥æºç‚¹æ˜¯å¦åœ¨å›¾åƒèŒƒå›´å†…
            if 0 <= src_x < w and 0 <= src_y < h:
                result[y, x] = img[src_y, src_x]

    return result
```

### æ€§èƒ½ä¼˜åŒ– ğŸš€

ä½¿ç”¨OpenMPå’Œè‡ªé€‚åº”å›¾åƒå¤§å°å®ç°é«˜æ•ˆæ—‹è½¬ï¼š

```cpp
Mat rotate(const Mat& src, double angle, const Point2f& center, double scale) {
    // è®¡ç®—æ—‹è½¬ä¸­å¿ƒ
    Point2f center_point = center;
    if(center.x < 0 || center.y < 0) {
        center_point = Point2f(src.cols/2.0f, src.rows/2.0f);
    }

    // è®¡ç®—æ—‹è½¬çŸ©é˜µ
    Mat M = getRotationMatrix2D(center_point, angle, scale);

    // è®¡ç®—æ—‹è½¬åçš„å›¾åƒå¤§å°
    double alpha = angle * CV_PI / 180.0;
    double cos_alpha = fabs(cos(alpha));
    double sin_alpha = fabs(sin(alpha));

    int new_w = static_cast<int>(src.cols * cos_alpha + src.rows * sin_alpha);
    int new_h = static_cast<int>(src.cols * sin_alpha + src.rows * cos_alpha);

    // è°ƒæ•´æ—‹è½¬ä¸­å¿ƒ
    M.at<double>(0,2) += (new_w/2.0 - center_point.x);
    M.at<double>(1,2) += (new_h/2.0 - center_point.y);

    return affine_transform(src, M, Size(new_w, new_h));
}
```

### å®æˆ˜å°è´´å£« ğŸŒŸ

1. æ—‹è½¬è§’åº¦é¢„å¤„ç†ï¼š
   ```python
   angle = angle % 360  # æ ‡å‡†åŒ–è§’åº¦
   if angle == 0: return img  # å¿«é€Ÿè·¯å¾„
   if angle == 90: return rotate_90(img)  # ç‰¹æ®Šè§’åº¦ä¼˜åŒ–
   ```

2. è¾¹ç•Œå¤„ç†æŠ€å·§ï¼š
   - ä½¿ç”¨åŒçº¿æ€§æ’å€¼æé«˜è´¨é‡
   - è€ƒè™‘æ˜¯å¦éœ€è¦è°ƒæ•´è¾“å‡ºå›¾åƒå¤§å°

3. å¸¸è§åº”ç”¨ï¼š
   - å›¾åƒæ–¹å‘æ ¡æ­£
   - äººè„¸å¯¹é½
   - æ–‡å­—æ–¹å‘è°ƒæ•´

## ç¼©æ”¾å˜æ¢

### ç†è®ºåŸºç¡€ ğŸ“

ç¼©æ”¾å˜æ¢å°±åƒç»™å›¾ç‰‡å–äº†"å˜å¤§å˜å°è¯æ°´"ã€‚å…¶æ•°å­¦è¡¨è¾¾å¼æ˜¯ï¼š

$$
S(s_x, s_y) = \begin{bmatrix}
s_x & 0 & 0 \\
0 & s_y & 0 \\
0 & 0 & 1
\end{bmatrix}
$$

å…¶ä¸­ï¼š
- $s_x$ æ˜¯xæ–¹å‘çš„ç¼©æ”¾æ¯”ä¾‹
- $s_y$ æ˜¯yæ–¹å‘çš„ç¼©æ”¾æ¯”ä¾‹

### æ‰‹åŠ¨å®ç° ğŸ”

```python
def scale_image(img_path, scale_x, scale_y):
    """
    ç¼©æ”¾å˜æ¢ï¼šå›¾åƒç•Œçš„"é­”æ³•è¯æ°´"

    å‚æ•°:
        img_path: è¾“å…¥å›¾åƒè·¯å¾„
        scale_x: xæ–¹å‘çš„ç¼©æ”¾æ¯”ä¾‹
        scale_y: yæ–¹å‘çš„ç¼©æ”¾æ¯”ä¾‹
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path)
    if img is None:
        raise ValueError(f"æ— æ³•è¯»å–å›¾åƒ: {img_path}")

    # è·å–å›¾åƒå°ºå¯¸
    h, w = img.shape[:2]

    # è®¡ç®—ç¼©æ”¾åçš„å°ºå¯¸
    new_w = int(w * scale_x)
    new_h = int(h * scale_y)

    # åˆ›å»ºè¾“å‡ºå›¾åƒ
    result = np.zeros((new_h, new_w, 3), dtype=np.uint8)

    # æ‰‹åŠ¨å®ç°ç¼©æ”¾
    for y in range(new_h):
        for x in range(new_w):
            # è®¡ç®—æºå›¾åƒä¸­çš„å¯¹åº”ç‚¹
            src_x = int(x / scale_x)
            src_y = int(y / scale_y)

            # æ£€æŸ¥æºç‚¹æ˜¯å¦åœ¨å›¾åƒèŒƒå›´å†…
            if 0 <= src_x < w and 0 <= src_y < h:
                result[y, x] = img[src_y, src_x]

    return result
```

### æ€§èƒ½ä¼˜åŒ– ğŸš€

ä½¿ç”¨OpenMPå’ŒåŒçº¿æ€§æ’å€¼å®ç°é«˜æ•ˆç¼©æ”¾ï¼š

```cpp
Mat resize(const Mat& src, const Size& size, int interpolation) {
    Mat dst(size, src.type());

    float scale_x = static_cast<float>(src.cols) / size.width;
    float scale_y = static_cast<float>(src.rows) / size.height;

    #pragma omp parallel for
    for(int y = 0; y < dst.rows; y++) {
        for(int x = 0; x < dst.cols; x++) {
            float src_x = x * scale_x;
            float src_y = y * scale_y;

            if(src_x >= 0 && src_x < src.cols-1 &&
               src_y >= 0 && src_y < src.rows-1) {
                if(src.type() == CV_8UC3) {
                    Vec3b p = bilinear_interpolation<Vec3b>(src, src_x, src_y);
                    dst.at<Vec3b>(y,x) = p;
                } else {
                    uchar p = bilinear_interpolation<uchar>(src, src_x, src_y);
                    dst.at<uchar>(y,x) = p;
                }
            }
        }
    }

    return dst;
}
```

### å®æˆ˜å°è´´å£« ğŸŒŸ

1. æ’å€¼æ–¹æ³•é€‰æ‹©ï¼š
   - æœ€è¿‘é‚»æ’å€¼ï¼šé€Ÿåº¦å¿«ï¼Œä½†å¯èƒ½æœ‰é”¯é½¿
   - åŒçº¿æ€§æ’å€¼ï¼šè´¨é‡å¥½ï¼Œä½†è®¡ç®—é‡å¤§
   - ä¸‰æ¬¡æ’å€¼ï¼šè´¨é‡æœ€å¥½ï¼Œä½†æœ€æ…¢

2. æ€§èƒ½ä¼˜åŒ–æŠ€å·§ï¼š
   ```python
   # ç‰¹æ®Šæƒ…å†µå¿«é€Ÿå¤„ç†
   if scale_x == 1.0 and scale_y == 1.0:
       return img.copy()
   if scale_x == 2.0 and scale_y == 2.0:
       return scale_2x_fast(img)  # ä½¿ç”¨ç‰¹æ®Šä¼˜åŒ–
   ```

3. å¸¸è§åº”ç”¨ï¼š
   - å›¾åƒç¼©ç•¥å›¾ç”Ÿæˆ
   - å›¾åƒé‡‘å­—å¡”æ„å»º
   - åˆ†è¾¨ç‡è°ƒæ•´

## å¹³ç§»å˜æ¢

### ç†è®ºåŸºç¡€ ğŸš¶

å¹³ç§»å˜æ¢å°±åƒè®©å›¾ç‰‡"æ•£æ­¥"ã€‚å…¶æ•°å­¦è¡¨è¾¾å¼æ˜¯ï¼š

$$
T(t_x, t_y) = \begin{bmatrix}
1 & 0 & t_x \\
0 & 1 & t_y \\
0 & 0 & 1
\end{bmatrix}
$$

å…¶ä¸­ï¼š
- $t_x$ æ˜¯xæ–¹å‘çš„å¹³ç§»è·ç¦»
- $t_y$ æ˜¯yæ–¹å‘çš„å¹³ç§»è·ç¦»

### æ‰‹åŠ¨å®ç° ğŸš¶â€â™‚ï¸

```python
def translate_image(img_path, tx, ty):
    """
    å¹³ç§»å˜æ¢ï¼šå›¾åƒç•Œçš„"æ•£æ­¥è¾¾äºº"

    å‚æ•°:
        img_path: è¾“å…¥å›¾åƒè·¯å¾„
        tx: xæ–¹å‘å¹³ç§»é‡ï¼ˆæ­£å€¼å‘å³ï¼Œè´Ÿå€¼å‘å·¦ï¼‰
        ty: yæ–¹å‘å¹³ç§»é‡ï¼ˆæ­£å€¼å‘ä¸‹ï¼Œè´Ÿå€¼å‘ä¸Šï¼‰
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path)
    if img is None:
        raise ValueError(f"æ— æ³•è¯»å–å›¾åƒ: {img_path}")

    # è·å–å›¾åƒå°ºå¯¸
    h, w = img.shape[:2]

    # åˆ›å»ºè¾“å‡ºå›¾åƒ
    result = np.zeros_like(img)

    # æ‰‹åŠ¨å®ç°å¹³ç§»
    for y in range(h):
        for x in range(w):
            # è®¡ç®—æºå›¾åƒä¸­çš„å¯¹åº”ç‚¹
            src_x = x - tx
            src_y = y - ty

            # æ£€æŸ¥æºç‚¹æ˜¯å¦åœ¨å›¾åƒèŒƒå›´å†…
            if 0 <= src_x < w and 0 <= src_y < h:
                result[y, x] = img[src_y, src_x]

    return result
```

### æ€§èƒ½ä¼˜åŒ– ğŸš€

ä½¿ç”¨ä»¿å°„å˜æ¢çŸ©é˜µå®ç°é«˜æ•ˆå¹³ç§»ï¼š

```cpp
Mat translate(const Mat& src, double dx, double dy) {
    Mat M = (Mat_<float>(2,3) << 1, 0, dx, 0, 1, dy);
    return affine_transform(src, M, src.size());
}
```

### å®æˆ˜å°è´´å£« ğŸŒŸ

1. è¾¹ç•Œå¤„ç†ç­–ç•¥ï¼š
   ```python
   # ä¸åŒè¾¹ç•Œæ¨¡å¼çš„æ•ˆæœ
   result_constant = translate_image(img, 50, 30, 'constant', 0)  # é»‘è‰²å¡«å……
   result_replicate = translate_image(img, 50, 30, 'replicate')   # è¾¹ç¼˜å¤åˆ¶
   result_reflect = translate_image(img, 50, 30, 'reflect')       # é•œåƒå¡«å……
   ```

2. æ€§èƒ½ä¼˜åŒ–æŠ€å·§ï¼š
   - å¯¹äºçº¯æ°´å¹³æˆ–çº¯å‚ç›´å¹³ç§»ï¼Œä½¿ç”¨å†…å­˜å¤åˆ¶
   - åˆ©ç”¨CPUç¼“å­˜è¡Œå¯¹é½ä¼˜åŒ–è®¿é—®æ¨¡å¼
   - è€ƒè™‘ä½¿ç”¨æŸ¥æ‰¾è¡¨é¢„è®¡ç®—è¾¹ç•Œç´¢å¼•

3. å¸¸è§åº”ç”¨ï¼š
   - å›¾åƒæ‹¼æ¥é¢„å¤„ç†
   - è§†é¢‘é˜²æŠ–å¤„ç†
   - UIåŠ¨ç”»æ•ˆæœ

## é•œåƒå˜æ¢

### ç†è®ºåŸºç¡€ ğŸª

é•œåƒå˜æ¢å°±åƒç…§é•œå­ï¼Œå¯ä»¥æ°´å¹³æˆ–å‚ç›´ç¿»è½¬å›¾åƒã€‚å…¶æ•°å­¦è¡¨è¾¾å¼æ˜¯ï¼š

æ°´å¹³ç¿»è½¬ï¼š
$$
M_h = \begin{bmatrix}
-1 & 0 & w-1 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{bmatrix}
$$

å‚ç›´ç¿»è½¬ï¼š
$$
M_v = \begin{bmatrix}
1 & 0 & 0 \\
0 & -1 & h-1 \\
0 & 0 & 1
\end{bmatrix}
$$

å…¶ä¸­ï¼š
- $w$ æ˜¯å›¾åƒå®½åº¦
- $h$ æ˜¯å›¾åƒé«˜åº¦

### æ‰‹åŠ¨å®ç° ğŸ­

```python
def mirror_image(img_path, direction='horizontal'):
    """
    é•œåƒå˜æ¢ï¼šå›¾åƒç•Œçš„"é­”é•œé­”é•œ"

    å‚æ•°:
        img_path: è¾“å…¥å›¾åƒè·¯å¾„
        direction: é•œåƒæ–¹å‘ ('horizontal' æˆ– 'vertical')
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path)
    if img is None:
        raise ValueError(f"æ— æ³•è¯»å–å›¾åƒ: {img_path}")

    # è·å–å›¾åƒå°ºå¯¸
    h, w = img.shape[:2]

    # åˆ›å»ºè¾“å‡ºå›¾åƒ
    result = np.zeros_like(img)

    # æ‰‹åŠ¨å®ç°é•œåƒ
    if direction == 'horizontal':
        # æ°´å¹³é•œåƒ
        for y in range(h):
            for x in range(w):
                result[y, x] = img[y, w-1-x]
    else:
        # å‚ç›´é•œåƒ
        for y in range(h):
            for x in range(w):
                result[y, x] = img[h-1-y, x]

    return result
```

### æ€§èƒ½ä¼˜åŒ– ğŸš€

ä½¿ç”¨OpenMPè¿›è¡Œå¹¶è¡Œå¤„ç†åŠ é€Ÿé•œåƒå˜æ¢ï¼š

```cpp
Mat mirror(const Mat& src, int flip_code) {
    Mat dst(src.size(), src.type());

    if(flip_code == 0) { // å‚ç›´ç¿»è½¬
        #pragma omp parallel for
        for(int y = 0; y < src.rows; y++) {
            for(int x = 0; x < src.cols; x++) {
                dst.at<Vec3b>(y,x) = src.at<Vec3b>(src.rows-1-y,x);
            }
        }
    }
    else if(flip_code > 0) { // æ°´å¹³ç¿»è½¬
        #pragma omp parallel for
        for(int y = 0; y < src.rows; y++) {
            for(int x = 0; x < src.cols; x++) {
                dst.at<Vec3b>(y,x) = src.at<Vec3b>(y,src.cols-1-x);
            }
        }
    }
    else { // åŒå‘ç¿»è½¬
        #pragma omp parallel for
        for(int y = 0; y < src.rows; y++) {
            for(int x = 0; x < src.cols; x++) {
                dst.at<Vec3b>(y,x) = src.at<Vec3b>(src.rows-1-y,src.cols-1-x);
            }
        }
    }

    return dst;
}
```

### å®æˆ˜å°è´´å£« ğŸŒŸ

1. å¿«é€Ÿå®ç°æŠ€å·§ï¼š
   ```python
   # NumPyåˆ‡ç‰‡æ“ä½œæ˜¯æœ€å¿«çš„å®ç°æ–¹å¼
   def quick_mirror(img, direction='horizontal'):
       return {
           'horizontal': lambda x: x[:, ::-1],
           'vertical': lambda x: x[::-1, :],
           'both': lambda x: x[::-1, ::-1]
       }[direction](img)
   ```

2. æ€§èƒ½ä¼˜åŒ–è¦ç‚¹ï¼š
   - ä½¿ç”¨å‘é‡åŒ–æ“ä½œä»£æ›¿å¾ªç¯
   - åˆ©ç”¨CPUç¼“å­˜è¡Œå¯¹é½
   - è€ƒè™‘ä½¿ç”¨å†…å­˜æ˜ å°„ä¼˜åŒ–å¤§å›¾åƒå¤„ç†

3. å¸¸è§åº”ç”¨ï¼š
   - å›¾åƒé¢„å¤„ç†å’Œæ•°æ®å¢å¼º
   - è‡ªæ‹å›¾åƒå¤„ç†
   - å›¾åƒå¯¹ç§°æ€§åˆ†æ

## ğŸš€ æ€§èƒ½ä¼˜åŒ–æŒ‡å—

### 1. SIMDåŠ é€Ÿ ğŸš€

ä½¿ç”¨CPUçš„SIMDæŒ‡ä»¤é›†ï¼ˆå¦‚SSE/AVXï¼‰å¯ä»¥åŒæ—¶å¤„ç†å¤šä¸ªåƒç´ ï¼š

```cpp
// ä½¿ç”¨AVX2ä¼˜åŒ–çš„ç¤ºä¾‹
__m256 process_pixels(__m256 x_coords, __m256 y_coords) {
    // åŒæ—¶å¤„ç†8ä¸ªåƒç´ 
    return _mm256_fmadd_ps(x_coords, y_coords, _mm256_set1_ps(1.0f));
}
```

### 2. å¤šçº¿ç¨‹ä¼˜åŒ– ğŸ§µ

ä½¿ç”¨OpenMPè¿›è¡Œå¹¶è¡Œè®¡ç®—ï¼š

```cpp
#pragma omp parallel for collapse(2)
for(int y = 0; y < height; y++) {
    for(int x = 0; x < width; x++) {
        // å¹¶è¡Œå¤„ç†æ¯ä¸ªåƒç´ 
    }
}
```

### 3. ç¼“å­˜ä¼˜åŒ– ğŸ’¾

- ä½¿ç”¨åˆ†å—å¤„ç†å‡å°‘ç¼“å­˜miss
- ä¿æŒæ•°æ®å¯¹é½
- é¿å…é¢‘ç¹çš„å†…å­˜åˆ†é…

```cpp
// åˆ†å—å¤„ç†ç¤ºä¾‹
constexpr int BLOCK_SIZE = 16;
for(int by = 0; by < height; by += BLOCK_SIZE) {
    for(int bx = 0; bx < width; bx += BLOCK_SIZE) {
        // å¤„ç†ä¸€ä¸ª16x16çš„å›¾åƒå—
    }
}
```

### 4. ç®—æ³•ä¼˜åŒ– ğŸ§®

- ä½¿ç”¨æŸ¥æ‰¾è¡¨é¢„è®¡ç®—
- é¿å…é™¤æ³•è¿ç®—
- åˆ©ç”¨ç‰¹æ®Šæƒ…å†µçš„å¿«é€Ÿè·¯å¾„

```python
# é¢„è®¡ç®—ç¤ºä¾‹
sin_table = [np.sin(angle) for angle in angles]
cos_table = [np.cos(angle) for angle in angles]

# å¿«é€Ÿè·¯å¾„ç¤ºä¾‹
if angle == 0: return img.copy()
if angle == 90: return rotate_90(img)
```

è®°ä½ï¼šä¼˜åŒ–æ˜¯ä¸€é—¨è‰ºæœ¯ï¼Œè¦åœ¨é€Ÿåº¦å’Œä»£ç å¯è¯»æ€§ä¹‹é—´æ‰¾åˆ°å¹³è¡¡ï¼ğŸ­

## ğŸ¯ å®æˆ˜ç»ƒä¹ 

1. å›¾åƒæ‹¼æ¥é­”æ³• ğŸ§©
   - å…¨æ™¯å›¾åƒæ‹¼æ¥
   - å¤šè§†è§’å›¾åƒåˆæˆ
   - å®æ—¶è§†é¢‘æ‹¼æ¥

2. æ–‡æ¡£æ‰«æå™¨ ğŸ“„
   - æ™ºèƒ½è¾¹ç¼˜æ£€æµ‹
   - è‡ªåŠ¨é€è§†æ ¡æ­£
   - æ–‡æ¡£å¢å¼ºå¤„ç†

3. å›¾åƒå˜æ¢è‰ºæœ¯ ğŸ¨
   - ä¸‡èŠ±ç­’æ•ˆæœ
   - æ³¢æµªå˜å½¢
   - æ—‹æ¶¡ç‰¹æ•ˆ

4. å®æ—¶å˜æ¢åº”ç”¨ ğŸ“±
   - å®æ—¶é•œåƒ
   - åŠ¨æ€æ—‹è½¬
   - ç¼©æ”¾é¢„è§ˆ

5. å›¾åƒæ ¡æ­£å¤§å¸ˆ ğŸ“
   - æ™ºèƒ½å€¾æ–œæ ¡æ­£
   - ç•¸å˜çŸ«æ­£
   - é€è§†æ ¡æ­£

> ğŸ’¡ æ›´å¤šç²¾å½©å†…å®¹å’Œè¯¦ç»†å®ç°,è¯·å…³æ³¨å¾®ä¿¡å…¬ä¼—å·ã€GlimmerLabã€‘,é¡¹ç›®æŒç»­æ›´æ–°ä¸­...
>
> ğŸŒŸ æ¬¢è¿è®¿é—®æˆ‘ä»¬çš„Githubé¡¹ç›®: [GlimmerLab](https://github.com/GlimmerLab/IP101)

## ğŸ“š å»¶ä¼¸é˜…è¯»

1. [OpenCVå®˜æ–¹æ–‡æ¡£](https://docs.opencv.org/)
2. [è®¡ç®—æœºè§†è§‰å®æˆ˜](https://www.learnopencv.com/)

> ğŸ’¡ è®°ä½ï¼šå›¾åƒå˜æ¢å°±åƒé­”æ³•ï¼ŒæŒæ¡äº†è¿™äº›æŠ€å·§ï¼Œä½ å°±æ˜¯è®¡ç®—æœºè§†è§‰ä¸–ç•Œçš„"å˜å½¢é‡‘åˆš"ï¼