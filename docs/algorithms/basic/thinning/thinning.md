# å›¾åƒç»†åŒ–ç®—æ³•è¯¦è§£ ğŸ¨

> æ¬¢è¿æ¥åˆ°å›¾åƒå¤„ç†çš„"ç˜¦èº«å·¥ä½œå®¤"ï¼åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•åƒä¸€ä½ç»†å¿ƒçš„é›•åˆ»å®¶ä¸€æ ·ï¼Œå°†å›¾åƒä¸­çš„ç›®æ ‡å¯¹è±¡"ç˜¦èº«"ä¸ºå•åƒç´ å®½åº¦çš„éª¨æ¶ã€‚è¿™ä¸ªè¿‡ç¨‹å°±åƒæŠŠä¸€æ¡ç²—çº¿æ¡é€æ¸"å‰Šç˜¦"æˆä¸€æ¡ç»†çº¿ï¼ŒåŒæ—¶ä¿æŒå…¶æ‹“æ‰‘ç»“æ„ä¸å˜ã€‚è®©æˆ‘ä»¬ä¸€èµ·æ¢ç´¢è¿™ä¸ªç¥å¥‡çš„"ç˜¦èº«é­”æ³•"å§ï¼ğŸš€

## ğŸ“š ç›®å½•
- [1. ç®—æ³•åŸç†](#1-ç®—æ³•åŸç†)
- [2. åº”ç”¨åœºæ™¯](#2-åº”ç”¨åœºæ™¯)
- [3. åŸºæœ¬ç»†åŒ–ç®—æ³•](#3-åŸºæœ¬ç»†åŒ–ç®—æ³•)
- [4. Hilditchç»†åŒ–ç®—æ³•](#4-hilditchç»†åŒ–ç®—æ³•)
- [5. Zhang-Suenç»†åŒ–ç®—æ³•](#5-zhang-suenç»†åŒ–ç®—æ³•)
- [6. éª¨æ¶æå–](#6-éª¨æ¶æå–)
- [7. ä¸­è½´å˜æ¢](#7-ä¸­è½´å˜æ¢)
- [8. ä¼˜åŒ–å»ºè®®](#8-ä¼˜åŒ–å»ºè®®)

## 1. ç®—æ³•åŸç†

å›¾åƒç»†åŒ–çš„æ ¸å¿ƒæ€æƒ³æ˜¯é€šè¿‡è¿­ä»£åˆ é™¤ç›®æ ‡è¾¹ç¼˜åƒç´ æ¥è·å¾—éª¨æ¶ã€‚è¿™ä¸ªè¿‡ç¨‹éœ€è¦ä¿è¯ï¼š

| åŸåˆ™ | è¯´æ˜ | é‡è¦æ€§ |
|------|------|--------|
| ä¿æŒè¿é€šæ€§ | ä¸èƒ½ç ´åç›®æ ‡çš„è¿æ¥å…³ç³» | â­â­â­â­â­ |
| é€‚åº¦ç»†åŒ– | ä¸èƒ½è¿‡åº¦è…èš€å¯¼è‡´ç›®æ ‡æ¶ˆå¤± | â­â­â­â­ |
| ä¸­å¿ƒå®šä½ | éª¨æ¶åº”è¯¥ä½äºç‰©ä½“çš„ä¸­å¿ƒä½ç½® | â­â­â­â­ |

å°±åƒé›•åˆ»å®¶ç²¾å¿ƒé›•ç¢æœ¨å¤´ä¸€æ ·ï¼Œæˆ‘ä»¬éœ€è¦å°å¿ƒç¿¼ç¿¼åœ°"å‰Šæ‰"è¾¹ç¼˜åƒç´ ï¼Œç›´åˆ°å¾—åˆ°ç†æƒ³çš„éª¨æ¶ã€‚ğŸ¯

## 2. åº”ç”¨åœºæ™¯

å›¾åƒç»†åŒ–ç®—æ³•åœ¨å¤šä¸ªé¢†åŸŸéƒ½æœ‰é‡è¦åº”ç”¨ï¼šğŸŒŸ

| åº”ç”¨é¢†åŸŸ | å…·ä½“åº”ç”¨ | æŠ€æœ¯è¦ç‚¹ |
|----------|----------|----------|
| ğŸ“ å­—ç¬¦è¯†åˆ« | æ‰‹å†™å­—ç¬¦ç»†åŒ– | ç‰¹å¾æå–å’Œè¯†åˆ« |
| ğŸ‘† æŒ‡çº¹è¯†åˆ« | æŒ‡çº¹éª¨æ¶æå– | æŒ‡çº¹åŒ¹é…å’Œè¯†åˆ« |
| ğŸ›£ï¸ é“è·¯æå– | é“è·¯ç½‘ç»œæå– | åœ°å›¾åˆ¶ä½œå’Œå¯¼èˆª |
| ğŸ¥ åŒ»å­¦å›¾åƒ | è¡€ç®¡ç½‘ç»œåˆ†æ | ç–¾ç—…è¯Šæ–­è¾…åŠ© |
| ğŸ¯ æ¨¡å¼è¯†åˆ« | ç›®æ ‡å½¢çŠ¶ç®€åŒ– | ç‰¹å¾åŒ¹é… |

## 3. åŸºæœ¬ç»†åŒ–ç®—æ³•

### 3.1 åŸºæœ¬åŸç†

æœ€åŸºæœ¬çš„ç»†åŒ–ç®—æ³•é‡‡ç”¨è¿­ä»£çš„æ–¹å¼,æ¯æ¬¡è¿­ä»£åˆ é™¤æ»¡è¶³ç‰¹å®šæ¡ä»¶çš„è¾¹ç•Œç‚¹ã€‚åˆ¤æ–­ä¸€ä¸ªç‚¹æ˜¯å¦å¯ä»¥åˆ é™¤é€šå¸¸éœ€è¦è€ƒè™‘å…¶8é‚»åŸŸåƒç´ çš„åˆ†å¸ƒæƒ…å†µã€‚

> ğŸ’¡ **æ•°å­¦å°è´´å£«**ï¼šåƒç´ é‚»åŸŸç¼–å·
> $$
> \begin{matrix}
> P_9 & P_2 & P_3 \\
> P_8 & P_1 & P_4 \\
> P_7 & P_6 & P_5
> \end{matrix}
> $$

æ¯æ¬¡è¿­ä»£å¿…é¡»æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š

| æ¡ä»¶ç±»å‹ | å…·ä½“æ¡ä»¶ | ä½œç”¨ |
|----------|----------|------|
| è¾¹ç•Œç‚¹æ¡ä»¶ | å½“å‰ç‚¹æ˜¯è¾¹ç•Œç‚¹ | ç¡®ä¿åªå¤„ç†è¾¹ç¼˜ |
| è¿é€šæ€§æ¡ä»¶ | 2 â‰¤ B(P1) â‰¤ 6 | ä¿æŒè¿é€šæ€§ |
| è¿ç»­æ€§æ¡ä»¶ | A(P1) = 1 | é¿å…è¿‡åº¦ç»†åŒ– |
| åˆ é™¤æ¡ä»¶ | P2 Ã— P4 Ã— P6 = 0 ä¸” P4 Ã— P6 Ã— P8 = 0 | ä¿æŒç»“æ„å®Œæ•´ |

### 3.2 C++å®ç°

```cpp
void basic_thinning(const Mat& src, Mat& dst) {
    CV_Assert(!src.empty() && src.type() == CV_8UC1);

    src.copyTo(dst);
    bool has_changed;

    do {
        has_changed = false;
        Mat tmp = dst.clone();

        #pragma omp parallel for collapse(2)
        for (int y = 1; y < dst.rows - 1; y++) {
            for (int x = 1; x < dst.cols - 1; x++) {
                if (tmp.at<uchar>(y, x) == 0) continue;

                // æ£€æŸ¥æ˜¯å¦ä¸ºè¾¹ç•Œç‚¹
                if (!is_boundary(tmp, y, x)) continue;

                // è®¡ç®—P2åˆ°P9çš„å€¼
                int p2 = tmp.at<uchar>(y-1, x) > 0;
                int p3 = tmp.at<uchar>(y-1, x+1) > 0;
                int p4 = tmp.at<uchar>(y, x+1) > 0;
                int p5 = tmp.at<uchar>(y+1, x+1) > 0;
                int p6 = tmp.at<uchar>(y+1, x) > 0;
                int p7 = tmp.at<uchar>(y+1, x-1) > 0;
                int p8 = tmp.at<uchar>(y, x-1) > 0;
                int p9 = tmp.at<uchar>(y-1, x-1) > 0;

                // æ¡ä»¶1ï¼š2 <= B(P1) <= 6
                int B = p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9;
                if (B < 2 || B > 6) continue;

                // æ¡ä»¶2ï¼šA(P1) = 1
                int A = count_transitions(tmp, y, x);
                if (A != 1) continue;

                // æ¡ä»¶3å’Œ4
                if ((p2 * p4 * p6 == 0) && (p4 * p6 * p8 == 0)) {
                    dst.at<uchar>(y, x) = 0;
                    has_changed = true;
                }
            }
        }
    } while (has_changed);
}
```

### 3.3 Pythonå®ç°

```python
def basic_thinning(img_path):
    """
    ä½¿ç”¨åŸºæœ¬ç»†åŒ–ç®—æ³•è¿›è¡Œå›¾åƒç»†åŒ–
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        raise ValueError(f"æ— æ³•è¯»å–å›¾åƒ: {img_path}")

    # äºŒå€¼åŒ–
    _, binary = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)

    # è½¬æ¢ä¸º0å’Œ1æ ¼å¼
    skeleton = binary.copy() // 255
    changing = True

    def is_boundary(img, y, x):
        if img[y, x] == 0:
            return False
        for dy in [-1, 0, 1]:
            for dx in [-1, 0, 1]:
                if dy == 0 and dx == 0:
                    continue
                ny, nx = y + dy, x + dx
                if 0 <= ny < img.shape[0] and 0 <= nx < img.shape[1]:
                    if img[ny, nx] == 0:
                        return True
        return False

    def count_transitions(img, y, x):
        values = [
            img[y-1, x],   # P2
            img[y-1, x+1], # P3
            img[y, x+1],   # P4
            img[y+1, x+1], # P5
            img[y+1, x],   # P6
            img[y+1, x-1], # P7
            img[y, x-1],   # P8
            img[y-1, x-1], # P9
            img[y-1, x]    # P2
        ]
        count = 0
        for i in range(len(values)-1):
            if values[i] == 0 and values[i+1] == 1:
                count += 1
        return count

    while changing:
        changing = False
        temp = skeleton.copy()

        for y in range(1, skeleton.shape[0]-1):
            for x in range(1, skeleton.shape[1]-1):
                if temp[y, x] == 0:
                    continue

                if not is_boundary(temp, y, x):
                    continue

                # è®¡ç®—P2åˆ°P9çš„å€¼
                p2, p3, p4, p5, p6, p7, p8, p9 = (
                    temp[y-1, x], temp[y-1, x+1], temp[y, x+1], temp[y+1, x+1],
                    temp[y+1, x], temp[y+1, x-1], temp[y, x-1], temp[y-1, x-1]
                )

                # æ¡ä»¶1ï¼š2 <= B(P1) <= 6
                B = p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9
                if B < 2 or B > 6:
                    continue

                # æ¡ä»¶2ï¼šA(P1) = 1
                A = count_transitions(temp, y, x)
                if A != 1:
                    continue

                # æ¡ä»¶3å’Œ4
                if (p2 * p4 * p6 == 0) and (p4 * p6 * p8 == 0):
                    skeleton[y, x] = 0
                    changing = True

    # è½¬æ¢å›0-255æ ¼å¼
    result = skeleton.astype(np.uint8) * 255
    return result
```

## 4. Hilditchç»†åŒ–ç®—æ³•

### 4.1 åŸºæœ¬åŸç†

Hilditchç»†åŒ–ç®—æ³•æ˜¯ä¸€ç§æ”¹è¿›çš„ç»†åŒ–ç®—æ³•ï¼Œæ ¹æ®ä»¥ä¸‹æ¡ä»¶åˆ¤æ–­æ˜¯å¦åˆ é™¤å½“å‰ç‚¹ï¼š

1. è¿é€šæ€§æ¡ä»¶ï¼š2 â‰¤ B(P1) â‰¤ 6
2. è¿ç»­æ€§æ¡ä»¶ï¼šA(P1) = 1
3. ç«¯ç‚¹æ¡ä»¶ï¼šP2 + P4 + P6 + P8 â‰¥ 1
4. åˆ é™¤æ¡ä»¶ï¼šP2 Ã— P4 Ã— P6 = 0 ä¸” P4 Ã— P6 Ã— P8 = 0

### 4.2 C++å®ç°

```cpp
void hilditch_thinning(const Mat& src, Mat& dst) {
    CV_Assert(!src.empty() && src.type() == CV_8UC1);

    src.copyTo(dst);
    bool has_changed;

    do {
        has_changed = false;
        Mat tmp = dst.clone();

        #pragma omp parallel for collapse(2)
        for (int y = 1; y < dst.rows - 1; y++) {
            for (int x = 1; x < dst.cols - 1; x++) {
                if (tmp.at<uchar>(y, x) == 0) continue;

                // è®¡ç®—Hilditchç®—æ³•æ¡ä»¶
                int B = count_nonzero_neighbors(tmp, y, x);
                if (B < 2 || B > 6) continue;

                int A = count_transitions(tmp, y, x);
                if (A != 1) continue;

                // è®¡ç®—è¿é€šæ€§
                int conn = 0;
                if (tmp.at<uchar>(y-1, x) > 0 && tmp.at<uchar>(y-1, x+1) > 0) conn++;
                if (tmp.at<uchar>(y-1, x+1) > 0 && tmp.at<uchar>(y, x+1) > 0) conn++;
                if (tmp.at<uchar>(y, x+1) > 0 && tmp.at<uchar>(y+1, x+1) > 0) conn++;
                if (tmp.at<uchar>(y+1, x+1) > 0 && tmp.at<uchar>(y+1, x) > 0) conn++;
                if (tmp.at<uchar>(y+1, x) > 0 && tmp.at<uchar>(y+1, x-1) > 0) conn++;
                if (tmp.at<uchar>(y+1, x-1) > 0 && tmp.at<uchar>(y, x-1) > 0) conn++;
                if (tmp.at<uchar>(y, x-1) > 0 && tmp.at<uchar>(y-1, x-1) > 0) conn++;
                if (tmp.at<uchar>(y-1, x-1) > 0 && tmp.at<uchar>(y-1, x) > 0) conn++;

                if (conn == 1) {
                    dst.at<uchar>(y, x) = 0;
                    has_changed = true;
                }
            }
        }
    } while (has_changed);
}
```

### 4.3 Pythonå®ç°

```python
def hilditch_thinning(img_path):
    """
    ä½¿ç”¨Hilditchç®—æ³•è¿›è¡Œå›¾åƒç»†åŒ–
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        raise ValueError(f"æ— æ³•è¯»å–å›¾åƒ: {img_path}")

    # äºŒå€¼åŒ–
    _, binary = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)

    # è½¬æ¢ä¸º0å’Œ1æ ¼å¼
    skeleton = binary.copy() // 255
    changing = True

    def count_nonzero_neighbors(img, y, x):
        count = 0
        for dy in [-1, 0, 1]:
            for dx in [-1, 0, 1]:
                if dy == 0 and dx == 0:
                    continue
                ny, nx = y + dy, x + dx
                if 0 <= ny < img.shape[0] and 0 <= nx < img.shape[1]:
                    if img[ny, nx] > 0:
                        count += 1
        return count

    def count_transitions(img, y, x):
        values = [
            img[y-1, x],   # P2
            img[y-1, x+1], # P3
            img[y, x+1],   # P4
            img[y+1, x+1], # P5
            img[y+1, x],   # P6
            img[y+1, x-1], # P7
            img[y, x-1],   # P8
            img[y-1, x-1], # P9
            img[y-1, x]    # P2
        ]
        count = 0
        for i in range(len(values)-1):
            if values[i] == 0 and values[i+1] == 1:
                count += 1
        return count

    while changing:
        changing = False
        temp = skeleton.copy()

        for y in range(1, skeleton.shape[0]-1):
            for x in range(1, skeleton.shape[1]-1):
                if temp[y, x] == 0:
                    continue

                # è®¡ç®—Hilditchç®—æ³•æ¡ä»¶
                B = count_nonzero_neighbors(temp, y, x)
                if B < 2 or B > 6:
                    continue

                A = count_transitions(temp, y, x)
                if A != 1:
                    continue

                # è®¡ç®—è¿é€šæ€§
                conn = 0
                if temp[y-1, x] > 0 and temp[y-1, x+1] > 0: conn += 1
                if temp[y-1, x+1] > 0 and temp[y, x+1] > 0: conn += 1
                if temp[y, x+1] > 0 and temp[y+1, x+1] > 0: conn += 1
                if temp[y+1, x+1] > 0 and temp[y+1, x] > 0: conn += 1
                if temp[y+1, x] > 0 and temp[y+1, x-1] > 0: conn += 1
                if temp[y+1, x-1] > 0 and temp[y, x-1] > 0: conn += 1
                if temp[y, x-1] > 0 and temp[y-1, x-1] > 0: conn += 1
                if temp[y-1, x-1] > 0 and temp[y-1, x] > 0: conn += 1

                if conn == 1:
                    skeleton[y, x] = 0
                    changing = True

    # è½¬æ¢å›0-255æ ¼å¼
    result = skeleton.astype(np.uint8) * 255
    return result
```

## 5. Zhang-Suenç»†åŒ–ç®—æ³•

### 5.1 åŸºæœ¬åŸç†

Zhang-Suenç»†åŒ–ç®—æ³•æ˜¯ä¸€ç§æ”¹è¿›çš„ç»†åŒ–ç®—æ³•ï¼Œé€šè¿‡ä¸¤æ¬¡è¿­ä»£æ¥ç»†åŒ–å›¾åƒï¼š

ç¬¬ä¸€æ¬¡è¿­ä»£æ¡ä»¶ï¼š
1. 2 â‰¤ B(P1) â‰¤ 6
2. A(P1) = 1
3. P2 Ã— P4 Ã— P6 = 0
4. P4 Ã— P6 Ã— P8 = 0

ç¬¬äºŒæ¬¡è¿­ä»£æ¡ä»¶ï¼š
1. 2 â‰¤ B(P1) â‰¤ 6
2. A(P1) = 1
3. P2 Ã— P4 Ã— P8 = 0
4. P2 Ã— P6 Ã— P8 = 0

### 5.2 C++å®ç°

```cpp
void zhang_suen_thinning(const Mat& src, Mat& dst) {
    CV_Assert(!src.empty() && src.type() == CV_8UC1);

    src.copyTo(dst);
    bool has_changed;

    do {
        has_changed = false;

        // ç¬¬ä¸€æ¬¡è¿­ä»£
        Mat tmp = dst.clone();
        #pragma omp parallel for collapse(2)
        for (int y = 1; y < dst.rows - 1; y++) {
            for (int x = 1; x < dst.cols - 1; x++) {
                if (tmp.at<uchar>(y, x) == 0) continue;

                int B = count_nonzero_neighbors(tmp, y, x);
                if (B < 2 || B > 6) continue;

                int A = count_transitions(tmp, y, x);
                if (A != 1) continue;

                // Zhang-Suenæ¡ä»¶1
                if (tmp.at<uchar>(y-1, x) * tmp.at<uchar>(y, x+1) * tmp.at<uchar>(y+1, x) == 0 &&
                    tmp.at<uchar>(y, x+1) * tmp.at<uchar>(y+1, x) * tmp.at<uchar>(y, x-1) == 0) {
                    dst.at<uchar>(y, x) = 0;
                    has_changed = true;
                }
            }
        }

        // ç¬¬äºŒæ¬¡è¿­ä»£
        tmp = dst.clone();
        #pragma omp parallel for collapse(2)
        for (int y = 1; y < dst.rows - 1; y++) {
            for (int x = 1; x < dst.cols - 1; x++) {
                if (tmp.at<uchar>(y, x) == 0) continue;

                int B = count_nonzero_neighbors(tmp, y, x);
                if (B < 2 || B > 6) continue;

                int A = count_transitions(tmp, y, x);
                if (A != 1) continue;

                // Zhang-Suenæ¡ä»¶2
                if (tmp.at<uchar>(y-1, x) * tmp.at<uchar>(y, x+1) * tmp.at<uchar>(y, x-1) == 0 &&
                    tmp.at<uchar>(y-1, x) * tmp.at<uchar>(y+1, x) * tmp.at<uchar>(y, x-1) == 0) {
                    dst.at<uchar>(y, x) = 0;
                    has_changed = true;
                }
            }
        }
    } while (has_changed);
}
```

### 5.3 Pythonå®ç°

```python
def zhang_suen_thinning(img_path):
    """
    ä½¿ç”¨Zhang-Suenç®—æ³•è¿›è¡Œå›¾åƒç»†åŒ–
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        raise ValueError(f"æ— æ³•è¯»å–å›¾åƒ: {img_path}")

    # äºŒå€¼åŒ–
    _, binary = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)

    # è½¬æ¢ä¸º0å’Œ1æ ¼å¼
    skeleton = binary.copy() // 255

    def zhang_suen_iteration(img, iter_type):
        changing = False
        rows, cols = img.shape

        # åˆ›å»ºæ ‡è®°æ•°ç»„
        markers = np.zeros_like(img)

        for i in range(1, rows-1):
            for j in range(1, cols-1):
                if img[i,j] == 1:
                    # è·å–8é‚»åŸŸ
                    p2,p3,p4,p5,p6,p7,p8,p9 = (img[i-1,j], img[i-1,j+1], img[i,j+1],
                                              img[i+1,j+1], img[i+1,j], img[i+1,j-1],
                                              img[i,j-1], img[i-1,j-1])

                    # è®¡ç®—æ¡ä»¶
                    A = 0
                    for k in range(len([p2,p3,p4,p5,p6,p7,p8,p9])-1):
                        if [p2,p3,p4,p5,p6,p7,p8,p9][k] == 0 and [p2,p3,p4,p5,p6,p7,p8,p9][k+1] == 1:
                            A += 1
                    B = sum([p2,p3,p4,p5,p6,p7,p8,p9])

                    m1 = p2 * p4 * p6 if iter_type == 0 else p2 * p4 * p8
                    m2 = p4 * p6 * p8 if iter_type == 0 else p2 * p6 * p8

                    if (A == 1 and B >= 2 and B <= 6 and m1 == 0 and m2 == 0):
                        markers[i,j] = 1
                        changing = True

        img[markers == 1] = 0
        return img, changing

    # è¿­ä»£ç»†åŒ–
    changing = True
    while changing:
        skeleton, changing1 = zhang_suen_iteration(skeleton, 0)
        skeleton, changing2 = zhang_suen_iteration(skeleton, 1)
        changing = changing1 or changing2

    # è½¬æ¢å›0-255æ ¼å¼
    result = skeleton.astype(np.uint8) * 255
    return result
```

## 6. éª¨æ¶æå–

### 6.1 åŸºæœ¬åŸç†

éª¨æ¶æå–æ˜¯ä¸€ç§ç‰¹æ®Šçš„ç»†åŒ–ç®—æ³•ï¼Œå®ƒé€šè¿‡å½¢æ€å­¦æ“ä½œæˆ–è·ç¦»å˜æ¢æ¥æå–å›¾åƒçš„ä¸­å¿ƒçº¿ã€‚éª¨æ¶å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

1. ä¿æŒåŸå›¾åƒçš„æ‹“æ‰‘ç»“æ„
2. ä½äºç‰©ä½“çš„ä¸­å¿ƒä½ç½®
3. å®½åº¦ä¸ºå•åƒç´ 
4. ä¿æŒç‰©ä½“çš„è¿é€šæ€§

### 6.2 C++å®ç°

```cpp
void skeleton_extraction(const Mat& src, Mat& dst) {
    CV_Assert(!src.empty() && src.type() == CV_8UC1);

    // ä½¿ç”¨è·ç¦»å˜æ¢å’Œå±€éƒ¨æœ€å¤§å€¼æå–éª¨æ¶
    Mat dist;
    distanceTransform(src, dist, DIST_L2, DIST_MASK_PRECISE);

    dst = Mat::zeros(src.size(), CV_8UC1);

    #pragma omp parallel for collapse(2)
    for (int y = 1; y < src.rows - 1; y++) {
        for (int x = 1; x < src.cols - 1; x++) {
            if (src.at<uchar>(y, x) == 0) continue;

            // æ£€æŸ¥æ˜¯å¦ä¸ºå±€éƒ¨æœ€å¤§å€¼
            float center = dist.at<float>(y, x);
            bool is_local_max = true;

            for (int dy = -1; dy <= 1 && is_local_max; dy++) {
                for (int dx = -1; dx <= 1; dx++) {
                    if (dy == 0 && dx == 0) continue;
                    if (dist.at<float>(y+dy, x+dx) > center) {
                        is_local_max = false;
                        break;
                    }
                }
            }

            if (is_local_max) {
                dst.at<uchar>(y, x) = 255;
            }
        }
    }
}
```

### 6.3 Pythonå®ç°

```python
def skeleton_extraction(img_path):
    """
    ä½¿ç”¨å½¢æ€å­¦æ“ä½œæå–å›¾åƒéª¨æ¶
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        raise ValueError(f"æ— æ³•è¯»å–å›¾åƒ: {img_path}")

    # äºŒå€¼åŒ–
    _, binary = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)

    # åˆ›å»ºç»“æ„å…ƒç´ 
    kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (3,3))

    # åˆå§‹åŒ–éª¨æ¶å›¾åƒ
    skeleton = np.zeros_like(binary)

    # è¿­ä»£æå–éª¨æ¶
    while True:
        # å½¢æ€å­¦å¼€è¿ç®—
        eroded = cv2.erode(binary, kernel)
        opened = cv2.dilate(eroded, kernel)

        # æå–éª¨æ¶ç‚¹
        temp = cv2.subtract(binary, opened)

        # æ›´æ–°éª¨æ¶å’ŒäºŒå€¼å›¾åƒ
        skeleton = cv2.bitwise_or(skeleton, temp)
        binary = eroded.copy()

        # å½“å›¾åƒä¸ºç©ºæ—¶åœæ­¢è¿­ä»£
        if cv2.countNonZero(binary) == 0:
            break

    return skeleton
```

## 7. ä¸­è½´å˜æ¢

### 7.1 åŸºæœ¬åŸç†

ä¸­è½´å˜æ¢(Medial Axis Transform, MAT)æ˜¯ä¸€ç§å°†äºŒç»´å½¢çŠ¶è½¬æ¢ä¸ºéª¨æ¶çš„æŠ€æœ¯ï¼Œå…¶ç‰¹ç‚¹æ˜¯ï¼š

1. éª¨æ¶ä¸Šçš„æ¯ä¸ªç‚¹éƒ½æ˜¯åˆ°è¾¹ç•Œçš„æœ€è¿œç‚¹
2. ä¿æŒäº†ç‰©ä½“çš„æ‹“æ‰‘ç»“æ„
3. å¯ä»¥ç”¨äºå½¢çŠ¶åˆ†æå’Œæè¿°
4. å¸¸ç”¨äºè®¡ç®—æœºè§†è§‰å’Œæ¨¡å¼è¯†åˆ«

### 7.2 C++å®ç°

```cpp
void medial_axis_transform(const Mat& src, Mat& dst, Mat& dist_transform) {
    CV_Assert(!src.empty() && src.type() == CV_8UC1);

    // è®¡ç®—è·ç¦»å˜æ¢
    distanceTransform(src, dist_transform, DIST_L2, DIST_MASK_PRECISE);

    // æå–ä¸­è½´
    dst = Mat::zeros(src.size(), CV_8UC1);

    #pragma omp parallel for
    for (int y = 1; y < src.rows - 1; y++) {
        for (int x = 1; x < src.cols - 1; x++) {
            if (src.at<uchar>(y, x) == 0) continue;

            float center = dist_transform.at<float>(y, x);
            bool is_medial_axis = false;

            // æ£€æŸ¥æ¢¯åº¦æ–¹å‘
            for (int dy = -1; dy <= 1; dy++) {
                for (int dx = -1; dx <= 1; dx++) {
                    if (dy == 0 && dx == 0) continue;
                    float neighbor = dist_transform.at<float>(y+dy, x+dx);

                    // å¦‚æœåœ¨ç›¸åæ–¹å‘ä¸Šæœ‰ç›¸åŒçš„è·ç¦»å€¼ï¼Œåˆ™ä¸ºä¸­è½´ç‚¹
                    if (abs(center - neighbor) < 1e-5) {
                        int opposite_y = y - dy;
                        int opposite_x = x - dx;
                        if (opposite_y >= 0 && opposite_y < src.rows &&
                            opposite_x >= 0 && opposite_x < src.cols) {
                            float opposite = dist_transform.at<float>(opposite_y, opposite_x);
                            if (abs(center - opposite) < 1e-5) {
                                is_medial_axis = true;
                                break;
                            }
                        }
                    }
                }
                if (is_medial_axis) break;
            }

            if (is_medial_axis) {
                dst.at<uchar>(y, x) = 255;
            }
        }
    }
}
```

### 7.3 Pythonå®ç°

```python
def medial_axis_transform(img_path):
    """
    è®¡ç®—å›¾åƒçš„ä¸­è½´å˜æ¢
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        raise ValueError(f"æ— æ³•è¯»å–å›¾åƒ: {img_path}")

    # äºŒå€¼åŒ–
    _, binary = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)

    # è®¡ç®—è·ç¦»å˜æ¢
    dist_transform = cv2.distanceTransform(binary, cv2.DIST_L2, 5)

    # å½’ä¸€åŒ–è·ç¦»å˜æ¢ç»“æœ
    cv2.normalize(dist_transform, dist_transform, 0, 255, cv2.NORM_MINMAX)

    # æå–å±€éƒ¨æœ€å¤§å€¼ä½œä¸ºä¸­è½´ç‚¹
    kernel = np.ones((3,3), dtype=np.uint8)
    dilated = cv2.dilate(dist_transform, kernel)
    medial_axis = (dist_transform == dilated) & (dist_transform > 20)

    # è½¬æ¢ä¸ºuint8ç±»å‹
    result = medial_axis.astype(np.uint8) * 255

    # è½¬æ¢ä¸ºå½©è‰²å›¾åƒ
    result = cv2.cvtColor(result, cv2.COLOR_GRAY2BGR)

    return result
```

## 8. ä¼˜åŒ–å»ºè®®

è¦æé«˜ç»†åŒ–ç®—æ³•çš„æ•ˆæœï¼Œå¯ä»¥è€ƒè™‘ä»¥ä¸‹ä¼˜åŒ–æ–¹å‘ï¼šğŸ”§

### 8.1 é¢„å¤„ç†ä¼˜åŒ–
   - ä½¿ç”¨ä¸­å€¼æ»¤æ³¢å»é™¤å™ªå£°
   - è¿›è¡Œé€‚å½“çš„äºŒå€¼åŒ–å¤„ç†
   - å¡«å……å°å­”æ´

### 8.2 ç®—æ³•é€‰æ‹©
- å¯¹äºç®€å•å›¾åƒï¼Œä½¿ç”¨åŸºæœ¬ç»†åŒ–ç®—æ³•
- å¯¹äºå¤æ‚å›¾åƒï¼Œä½¿ç”¨Zhang-Suenç®—æ³•
- éœ€è¦ä¿æŒæ‹“æ‰‘ç»“æ„æ—¶ï¼Œé€‰æ‹©Hilditchç®—æ³•

### 8.3 åå¤„ç†ä¼˜åŒ–
   - å»é™¤æ¯›åˆº
   - å¹³æ»‘éª¨æ¶
   - ä¿®å¤æ–­ç‚¹

### 8.4 å¹¶è¡ŒåŒ–å¤„ç†
   - ä½¿ç”¨GPUåŠ é€Ÿ
   - å›¾åƒåˆ†å—å¤„ç†
   - å¤šçº¿ç¨‹ä¼˜åŒ–

## ğŸ¯ æ€»ç»“

å›¾åƒç»†åŒ–æ˜¯ä¸€ä¸ªæ—¢ä¼˜é›…åˆå®ç”¨çš„ç®—æ³•ï¼Œå°±åƒä¸€ä½ç»†å¿ƒçš„é›•åˆ»å®¶ï¼Œå®ƒèƒ½å¤Ÿå°†å¤æ‚çš„å›¾åƒç®€åŒ–ä¸ºæœ€æœ¬è´¨çš„éª¨æ¶ç»“æ„ã€‚æŒæ¡è¿™ä¸ªç®—æ³•ï¼Œå°±åƒæ‹¥æœ‰äº†ä¸€æŠŠ"ç˜¦èº«é­”æ³•æ£’"ï¼Œèƒ½å¤Ÿå¸®åŠ©æˆ‘ä»¬æ›´å¥½åœ°ç†è§£å’Œåˆ†æå›¾åƒï¼ğŸ¨âœ¨

è®°ä½ï¼Œå¥½çš„ç»†åŒ–æ•ˆæœéœ€è¦ï¼š
1. åˆé€‚çš„é¢„å¤„ç†
2. æ­£ç¡®çš„ç®—æ³•é€‰æ‹©
3. ç»†è‡´çš„å‚æ•°è°ƒä¼˜
4. é€‚å½“çš„åå¤„ç†

è®©æˆ‘ä»¬ä¸€èµ·æ¢ç´¢å›¾åƒç»†åŒ–çš„å¥¥ç§˜ï¼Œåˆ›é€ æ›´å¤šç²¾å½©çš„åº”ç”¨ï¼ğŸš€