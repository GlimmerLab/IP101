# ğŸŒŸ å›¾åƒå¢å¼ºé­”æ³•æŒ‡å—

> ğŸ¨ åœ¨å›¾åƒå¤„ç†çš„ä¸–ç•Œé‡Œï¼Œå¢å¼ºå°±åƒæ˜¯ç»™å›¾ç‰‡åŒ–å¦†ï¼Œè®©å®ƒå±•ç°å‡ºæœ€ä½³çš„çŠ¶æ€ã€‚è®©æˆ‘ä»¬ä¸€èµ·æ¥æ¢ç´¢è¿™äº›ç¥å¥‡çš„å¢å¼ºæœ¯å§ï¼

## ğŸ“š ç›®å½•

1. [åŸºç¡€æ¦‚å¿µ - å›¾åƒå¢å¼ºçš„"ç¾å®¹é™¢"](#1-ä»€ä¹ˆæ˜¯å›¾åƒå¢å¼º)
2. [ç›´æ–¹å›¾å‡è¡¡åŒ– - å…‰çº¿çš„"å‡è¡¡å¸ˆ"](#2-ç›´æ–¹å›¾å‡è¡¡åŒ–)
3. [ä¼½é©¬å˜æ¢ - æ›å…‰çš„"è°ƒèŠ‚å¸ˆ"](#3-ä¼½é©¬å˜æ¢)
4. [å¯¹æ¯”åº¦æ‹‰ä¼¸ - å›¾åƒçš„"æ‹‰ç­‹å¸ˆ"](#4-å¯¹æ¯”åº¦æ‹‰ä¼¸)
5. [äº®åº¦è°ƒæ•´ - å…‰çº¿çš„"è°ƒå…‰å¸ˆ"](#5-äº®åº¦è°ƒæ•´)
6. [é¥±å’Œåº¦è°ƒæ•´ - è‰²å½©çš„"è°ƒè‰²å¸ˆ"](#6-é¥±å’Œåº¦è°ƒæ•´)
7. [ä»£ç å®ç° - å¢å¼ºçš„"å·¥å…·ç®±"](#7-ä»£ç å®ç°ä¸ä¼˜åŒ–)
8. [å®éªŒæ•ˆæœ - å¢å¼ºçš„"æˆæœå±•"](#8-å®éªŒæ•ˆæœä¸åº”ç”¨)

## 1. ä»€ä¹ˆæ˜¯å›¾åƒå¢å¼ºï¼Ÿ

å›¾åƒå¢å¼ºå°±åƒæ˜¯ç»™ç…§ç‰‡åš"ç¾å®¹"ï¼Œä¸»è¦ç›®çš„æ˜¯ï¼š
- ğŸ” æé«˜å›¾åƒçš„è§†è§‰æ•ˆæœ
- ğŸ¯ çªå‡ºæ„Ÿå…´è¶£çš„ç‰¹å¾
- ğŸ› ï¸ æ”¹å–„å›¾åƒè´¨é‡
- ğŸ“Š ä¼˜åŒ–å›¾åƒæ˜¾ç¤ºæ•ˆæœ

å¸¸è§çš„å¢å¼ºæ“ä½œåŒ…æ‹¬ï¼š
- è°ƒæ•´äº®åº¦å’Œå¯¹æ¯”åº¦
- æ”¹å–„å›¾åƒæ¸…æ™°åº¦
- å¢å¼ºè¾¹ç¼˜ç»†èŠ‚
- è°ƒæ•´è‰²å½©é¥±å’Œåº¦

## 2. ç›´æ–¹å›¾å‡è¡¡åŒ–

### 2.1 åŸºæœ¬åŸç†

ç›´æ–¹å›¾å‡è¡¡åŒ–å°±åƒæ˜¯ç»™å›¾åƒ"è°ƒæ•´å…‰çº¿åˆ†å¸ƒ"ï¼Œè®©æš—çš„åœ°æ–¹å˜äº®ï¼Œäº®çš„åœ°æ–¹é€‚å½“å‹æš—ï¼Œä½¿å¾—æ•´ä½“æ›´åŠ å’Œè°ã€‚

æ•°å­¦è¡¨è¾¾å¼ï¼š
å¯¹äºç°åº¦å›¾åƒï¼Œè®¾åŸå§‹å›¾åƒçš„ç°åº¦å€¼ä¸º$r_k$ï¼Œå˜æ¢åçš„ç°åº¦å€¼ä¸º$s_k$ï¼Œåˆ™ï¼š

$$
s_k = T(r_k) = (L-1)\sum_{j=0}^k \frac{n_j}{n}
$$

å…¶ä¸­ï¼š
- $L$ æ˜¯ç°åº¦çº§æ•°ï¼ˆé€šå¸¸ä¸º256ï¼‰
- $n_j$ æ˜¯ç°åº¦å€¼ä¸ºjçš„åƒç´ æ•°é‡
- $n$ æ˜¯å›¾åƒæ€»åƒç´ æ•°
- $k$ æ˜¯å½“å‰ç°åº¦å€¼ï¼ˆ0åˆ°L-1ï¼‰

### 2.2 å®ç°æ–¹æ³•

1. å…¨å±€ç›´æ–¹å›¾å‡è¡¡åŒ–ï¼š
   - è®¡ç®—æ•´å¹…å›¾åƒçš„ç›´æ–¹å›¾
   - è®¡ç®—ç´¯ç§¯åˆ†å¸ƒå‡½æ•°(CDF)
   - è¿›è¡Œç°åº¦æ˜ å°„

2. è‡ªé€‚åº”ç›´æ–¹å›¾å‡è¡¡åŒ–(CLAHE)ï¼š
   - å°†å›¾åƒåˆ†æˆå°å—
   - å¯¹æ¯ä¸ªå°å—è¿›è¡Œå‡è¡¡åŒ–
   - ä½¿ç”¨åŒçº¿æ€§æ’å€¼åˆå¹¶ç»“æœ

### 2.3 æ‰‹åŠ¨å®ç°

#### C++å®ç°
```cpp
void histogram_equalization(const Mat& src, Mat& dst) {
    CV_Assert(!src.empty() && src.channels() == 1);

    // è®¡ç®—ç›´æ–¹å›¾
    Mat hist, cdf;
    calculate_histogram(src, hist);
    calculate_cdf(hist, cdf);

    // å½’ä¸€åŒ–CDF
    double scale = 255.0 / (src.rows * src.cols);

    // åº”ç”¨æ˜ å°„
    dst.create(src.size(), src.type());
    #pragma omp parallel for
    for (int y = 0; y < src.rows; y++) {
        for (int x = 0; x < src.cols; x++) {
            dst.at<uchar>(y, x) = saturate_cast<uchar>(
                cdf.at<int>(src.at<uchar>(y, x)) * scale);
        }
    }
}
```

#### Pythonå®ç°
```python
def histogram_equalization_manual(image):
    """æ‰‹åŠ¨å®ç°ç›´æ–¹å›¾å‡è¡¡åŒ–

    å‚æ•°:
        image: è¾“å…¥ç°åº¦å›¾åƒ
    """
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    # è®¡ç®—ç›´æ–¹å›¾
    hist = np.zeros(256, dtype=np.int32)
    for y in range(gray.shape[0]):
        for x in range(gray.shape[1]):
            hist[gray[y, x]] += 1

    # è®¡ç®—ç´¯ç§¯ç›´æ–¹å›¾
    cum_hist = np.zeros(256, dtype=np.int32)
    cum_hist[0] = hist[0]
    for i in range(1, 256):
        cum_hist[i] = cum_hist[i-1] + hist[i]

    # å½’ä¸€åŒ–ç´¯ç§¯ç›´æ–¹å›¾
    norm_cum_hist = cum_hist * 255 / cum_hist[-1]

    # åº”ç”¨æ˜ å°„
    result = np.zeros_like(gray)
    for y in range(gray.shape[0]):
        for x in range(gray.shape[1]):
            result[y, x] = norm_cum_hist[gray[y, x]]

    return result.astype(np.uint8)
```

## 3. ä¼½é©¬å˜æ¢

### 3.1 åŸºæœ¬åŸç†

ä¼½é©¬å˜æ¢å°±åƒæ˜¯ç»™å›¾åƒè°ƒæ•´"æ›å…‰åº¦"ï¼Œå¯ä»¥æœ‰æ•ˆåœ°æ”¹å˜å›¾åƒçš„æ•´ä½“äº®åº¦ã€‚

æ•°å­¦è¡¨è¾¾å¼ï¼š
$$
s = cr^\gamma
$$

å…¶ä¸­ï¼š
- $r$ æ˜¯è¾“å…¥åƒç´ å€¼ï¼ˆ0åˆ°1ä¹‹é—´ï¼‰
- $s$ æ˜¯è¾“å‡ºåƒç´ å€¼ï¼ˆ0åˆ°1ä¹‹é—´ï¼‰
- $c$ æ˜¯å¸¸æ•°ï¼ˆé€šå¸¸å–1ï¼‰
- $\gamma$ æ˜¯ä¼½é©¬å€¼
  - $\gamma > 1$ å›¾åƒå˜æš—
  - $\gamma < 1$ å›¾åƒå˜äº®
  - $\gamma = 1$ å›¾åƒä¸å˜

### 3.2 æ‰‹åŠ¨å®ç°

#### C++å®ç°
```cpp
void gamma_correction(const Mat& src, Mat& dst, double gamma) {
    CV_Assert(!src.empty());

    // åˆ›å»ºæŸ¥æ‰¾è¡¨
    uchar lut[256];
    for (int i = 0; i < 256; i++) {
        lut[i] = saturate_cast<uchar>(pow(i / 255.0, gamma) * 255.0);
    }

    dst.create(src.size(), src.type());

    if (src.channels() == 1) {
        #pragma omp parallel for
        for (int y = 0; y < src.rows; y++) {
            for (int x = 0; x < src.cols; x++) {
                dst.at<uchar>(y, x) = lut[src.at<uchar>(y, x)];
            }
        }
    } else {
        #pragma omp parallel for
        for (int y = 0; y < src.rows; y++) {
            for (int x = 0; x < src.cols; x++) {
                const Vec3b& pixel = src.at<Vec3b>(y, x);
                dst.at<Vec3b>(y, x) = Vec3b(lut[pixel[0]], lut[pixel[1]], lut[pixel[2]]);
            }
        }
    }
}
```

#### Pythonå®ç°
```python
def gamma_correction_manual(image, gamma=1.0):
    """æ‰‹åŠ¨å®ç°ä¼½é©¬å˜æ¢

    å‚æ•°:
        image: è¾“å…¥å›¾åƒ
        gamma: ä¼½é©¬å€¼
    """
    # å½’ä¸€åŒ–åˆ°[0,1]èŒƒå›´
    image_normalized = image.astype(float) / 255.0

    # åº”ç”¨ä¼½é©¬å˜æ¢
    gamma_corrected = np.power(image_normalized, gamma)

    # è½¬å›[0,255]èŒƒå›´
    gamma_corrected = (gamma_corrected * 255).astype(np.uint8)

    return gamma_corrected
```

## 4. å¯¹æ¯”åº¦æ‹‰ä¼¸

### 4.1 åŸºæœ¬åŸç†

å¯¹æ¯”åº¦æ‹‰ä¼¸å°±åƒæ˜¯ç»™å›¾åƒ"æ‹‰ç­‹"ï¼Œè®©æš—éƒ¨æ›´æš—ï¼Œäº®éƒ¨æ›´äº®ï¼Œå¢åŠ å›¾åƒçš„"å¼ åŠ›"ã€‚

æ•°å­¦è¡¨è¾¾å¼ï¼š
$$
s = \frac{r - r_{min}}{r_{max} - r_{min}}(s_{max} - s_{min}) + s_{min}
$$

å…¶ä¸­ï¼š
- $r$ æ˜¯è¾“å…¥åƒç´ å€¼
- $s$ æ˜¯è¾“å‡ºåƒç´ å€¼
- $r_{min}, r_{max}$ æ˜¯è¾“å…¥å›¾åƒçš„æœ€å°å’Œæœ€å¤§ç°åº¦å€¼
- $s_{min}, s_{max}$ æ˜¯æœŸæœ›çš„è¾“å‡ºèŒƒå›´

### 4.2 æ‰‹åŠ¨å®ç°

#### C++å®ç°
```cpp
void contrast_stretching(const Mat& src, Mat& dst,
                        double min_out, double max_out) {
    CV_Assert(!src.empty());

    // æ‰¾åˆ°æœ€å°å’Œæœ€å¤§åƒç´ å€¼
    double min_val, max_val;
    minMaxLoc(src, &min_val, &max_val);

    dst.create(src.size(), src.type());
    double scale = (max_out - min_out) / (max_val - min_val);

    if (src.channels() == 1) {
        #pragma omp parallel for
        for (int y = 0; y < src.rows; y++) {
            for (int x = 0; x < src.cols; x++) {
                dst.at<uchar>(y, x) = saturate_cast<uchar>(
                    (src.at<uchar>(y, x) - min_val) * scale + min_out);
            }
        }
    } else {
        #pragma omp parallel for
        for (int y = 0; y < src.rows; y++) {
            for (int x = 0; x < src.cols; x++) {
                const Vec3b& pixel = src.at<Vec3b>(y, x);
                dst.at<Vec3b>(y, x) = Vec3b(
                    saturate_cast<uchar>((pixel[0] - min_val) * scale + min_out),
                    saturate_cast<uchar>((pixel[1] - min_val) * scale + min_out),
                    saturate_cast<uchar>((pixel[2] - min_val) * scale + min_out)
                );
            }
        }
    }
}
```

#### Pythonå®ç°
```python
def contrast_stretching_manual(image, low_percentile=1, high_percentile=99):
    """æ‰‹åŠ¨å®ç°å¯¹æ¯”åº¦æ‹‰ä¼¸

    å‚æ•°:
        image: è¾“å…¥å›¾åƒ
        low_percentile: ä½ç™¾åˆ†ä½æ•°ï¼Œé»˜è®¤1
        high_percentile: é«˜ç™¾åˆ†ä½æ•°ï¼Œé»˜è®¤99
    """
    # è®¡ç®—ç™¾åˆ†ä½æ•°
    low = np.percentile(image, low_percentile)
    high = np.percentile(image, high_percentile)

    # çº¿æ€§æ‹‰ä¼¸
    stretched = np.clip((image - low) * 255.0 / (high - low), 0, 255).astype(np.uint8)

    return stretched
```

## 5. äº®åº¦è°ƒæ•´

### 5.1 åŸºæœ¬åŸç†

äº®åº¦è°ƒæ•´å°±åƒæ˜¯ç»™å›¾åƒè°ƒæ•´"ç¯å…‰"ï¼Œå¯ä»¥è®©æ•´ä½“å˜äº®æˆ–å˜æš—ã€‚

æ•°å­¦è¡¨è¾¾å¼ï¼š
$$
s = r + \beta
$$

å…¶ä¸­ï¼š
- $r$ æ˜¯è¾“å…¥åƒç´ å€¼
- $s$ æ˜¯è¾“å‡ºåƒç´ å€¼
- $\beta$ æ˜¯äº®åº¦è°ƒæ•´å€¼
  - $\beta > 0$ å¢åŠ äº®åº¦
  - $\beta < 0$ é™ä½äº®åº¦

### 5.2 æ‰‹åŠ¨å®ç°

#### C++å®ç°
```cpp
void brightness_adjustment(const Mat& src, Mat& dst, double beta) {
    CV_Assert(!src.empty());

    dst.create(src.size(), src.type());

    if (src.channels() == 1) {
        #pragma omp parallel for
        for (int y = 0; y < src.rows; y++) {
            for (int x = 0; x < src.cols; x++) {
                dst.at<uchar>(y, x) = saturate_cast<uchar>(src.at<uchar>(y, x) + beta);
            }
        }
    } else {
        #pragma omp parallel for
        for (int y = 0; y < src.rows; y++) {
            for (int x = 0; x < src.cols; x++) {
                const Vec3b& pixel = src.at<Vec3b>(y, x);
                dst.at<Vec3b>(y, x) = Vec3b(
                    saturate_cast<uchar>(pixel[0] + beta),
                    saturate_cast<uchar>(pixel[1] + beta),
                    saturate_cast<uchar>(pixel[2] + beta)
                );
            }
        }
    }
}
```

#### Pythonå®ç°
```python
def brightness_adjustment_manual(image, beta):
    """æ‰‹åŠ¨å®ç°äº®åº¦è°ƒæ•´

    å‚æ•°:
        image: è¾“å…¥å›¾åƒ
        beta: äº®åº¦è°ƒæ•´å€¼ï¼Œæ­£å€¼å¢åŠ äº®åº¦ï¼Œè´Ÿå€¼é™ä½äº®åº¦
    """
    # ç›´æ¥åŠ å‡äº®åº¦å€¼
    adjusted = np.clip(image.astype(float) + beta, 0, 255).astype(np.uint8)

    return adjusted
```

## 6. é¥±å’Œåº¦è°ƒæ•´

### 6.1 åŸºæœ¬åŸç†

é¥±å’Œåº¦è°ƒæ•´å°±åƒæ˜¯ç»™å›¾åƒè°ƒæ•´"è‰²å½©æµ“åº¦"ï¼Œå¯ä»¥è®©é¢œè‰²æ›´é²œè‰³æˆ–æ›´æ·¡é›…ã€‚

æ•°å­¦è¡¨è¾¾å¼ï¼š
$$
s = r \cdot (1 - \alpha) + r_{avg} \cdot \alpha
$$

å…¶ä¸­ï¼š
- $r$ æ˜¯è¾“å…¥åƒç´ å€¼
- $s$ æ˜¯è¾“å‡ºåƒç´ å€¼
- $r_{avg}$ æ˜¯åƒç´ çš„ç°åº¦å€¼
- $\alpha$ æ˜¯é¥±å’Œåº¦è°ƒæ•´ç³»æ•°
  - $\alpha > 1$ å¢åŠ é¥±å’Œåº¦
  - $\alpha < 1$ é™ä½é¥±å’Œåº¦

### 6.2 æ‰‹åŠ¨å®ç°

#### C++å®ç°
```cpp
void saturation_adjustment(const Mat& src, Mat& dst, double saturation) {
    CV_Assert(!src.empty() && src.type() == CV_8UC3);

    // è½¬æ¢ä¸ºHSVç©ºé—´
    Mat hsv;
    cvtColor(src, hsv, COLOR_BGR2HSV);

    vector<Mat> channels;
    split(hsv, channels);

    // è°ƒæ•´é¥±å’Œåº¦é€šé“
    #pragma omp parallel for
    for (int y = 0; y < src.rows; y++) {
        for (int x = 0; x < src.cols; x++) {
            channels[1].at<uchar>(y, x) = saturate_cast<uchar>(
                channels[1].at<uchar>(y, x) * saturation);
        }
    }

    merge(channels, hsv);
    cvtColor(hsv, dst, COLOR_HSV2BGR);
}
```

#### Pythonå®ç°
```python
def saturation_adjustment_manual(image, alpha):
    """æ‰‹åŠ¨å®ç°é¥±å’Œåº¦è°ƒæ•´

    å‚æ•°:
        image: è¾“å…¥çš„RGBå›¾åƒ
        alpha: é¥±å’Œåº¦è°ƒæ•´ç³»æ•°ï¼Œ>1å¢åŠ é¥±å’Œåº¦ï¼Œ<1é™ä½é¥±å’Œåº¦
    """
    if len(image.shape) != 3:
        raise ValueError("è¾“å…¥å›¾åƒå¿…é¡»æ˜¯RGBå›¾åƒ")

    # è½¬æ¢ä¸ºHSVè‰²å½©ç©ºé—´
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV).astype(np.float32)

    # è°ƒæ•´é¥±å’Œåº¦é€šé“
    hsv[..., 1] = np.clip(hsv[..., 1] * alpha, 0, 255)

    # è½¬æ¢å›BGRè‰²å½©ç©ºé—´
    adjusted = cv2.cvtColor(hsv.astype(np.uint8), cv2.COLOR_HSV2BGR)

    return adjusted
```

## 7. ä»£ç å®ç°ä¸ä¼˜åŒ–

### 7.1 æ€§èƒ½ä¼˜åŒ–æŠ€å·§

1. SIMDåŠ é€Ÿï¼š
```cpp
// ä½¿ç”¨AVX2æŒ‡ä»¤é›†åŠ é€Ÿç›´æ–¹å›¾è®¡ç®—
inline void calculate_histogram_simd(const uchar* src, int* hist, int width) {
    alignas(32) int local_hist[256] = {0};

    for (int x = 0; x < width; x += 32) {
        __m256i pixels = _mm256_loadu_si256((__m256i*)(src + x));
        for (int i = 0; i < 32; i++) {
            local_hist[_mm256_extract_epi8(pixels, i)]++;
        }
    }
}
```

2. OpenMPå¹¶è¡ŒåŒ–ï¼š
```cpp
#pragma omp parallel for collapse(2)
for (int y = 0; y < src.rows; y++) {
    for (int x = 0; x < src.cols; x++) {
        // å¤„ç†æ¯ä¸ªåƒç´ 
    }
}
```

3. å†…å­˜å¯¹é½ï¼š
```cpp
alignas(32) float buffer[256];  // AVX2å¯¹é½
```

### 7.2 å…³é”®ä»£ç å®ç°

```cpp
// ç›´æ–¹å›¾å‡è¡¡åŒ–
void histogram_equalization(const Mat& src, Mat& dst) {
    // ... å®ç°ä»£ç  ...
}

// ä¼½é©¬å˜æ¢
void gamma_correction(const Mat& src, Mat& dst, double gamma) {
    // ... å®ç°ä»£ç  ...
}

// å¯¹æ¯”åº¦æ‹‰ä¼¸
void contrast_stretching(const Mat& src, Mat& dst) {
    // ... å®ç°ä»£ç  ...
}
```

## 8. å®éªŒæ•ˆæœä¸åº”ç”¨

### 8.1 åº”ç”¨åœºæ™¯

1. ç…§ç‰‡å¤„ç†ï¼š
   - é€†å…‰ç…§ç‰‡ä¿®æ­£
   - å¤œæ™¯ç…§ç‰‡å¢å¼º
   - è€ç…§ç‰‡ä¿®å¤

2. åŒ»å­¦å›¾åƒï¼š
   - Xå…‰ç‰‡å¢å¼º
   - CTå›¾åƒä¼˜åŒ–
   - è¶…å£°å›¾åƒå¤„ç†

3. é¥æ„Ÿå›¾åƒï¼š
   - å«æ˜Ÿå›¾åƒå¢å¼º
   - åœ°å½¢å›¾ä¼˜åŒ–
   - æ°”è±¡å›¾åƒå¤„ç†

### 8.2 æ³¨æ„äº‹é¡¹

1. å¢å¼ºè¿‡ç¨‹ä¸­çš„æ³¨æ„ç‚¹ï¼š
   - é¿å…è¿‡åº¦å¢å¼º
   - ä¿æŒç»†èŠ‚ä¸å¤±çœŸ
   - æ§åˆ¶å™ªå£°æ”¾å¤§

2. ç®—æ³•é€‰æ‹©å»ºè®®ï¼š
   - æ ¹æ®å›¾åƒç‰¹ç‚¹é€‰æ‹©
   - è€ƒè™‘å®æ—¶æ€§è¦æ±‚
   - æƒè¡¡è´¨é‡å’Œæ•ˆç‡

## æ€»ç»“

å›¾åƒå¢å¼ºå°±åƒæ˜¯ç»™ç…§ç‰‡å¼€äº†ä¸€å®¶"ç¾å®¹é™¢"ï¼é€šè¿‡ç›´æ–¹å›¾å‡è¡¡åŒ–ã€ä¼½é©¬å˜æ¢ã€å¯¹æ¯”åº¦æ‹‰ä¼¸ç­‰"ç¾å®¹é¡¹ç›®"ï¼Œæˆ‘ä»¬å¯ä»¥è®©å›¾åƒç„•å‘æ–°çš„æ´»åŠ›ã€‚åœ¨å®é™…åº”ç”¨ä¸­ï¼Œéœ€è¦æ ¹æ®å…·ä½“åœºæ™¯é€‰æ‹©åˆé€‚çš„"ç¾å®¹æ–¹æ¡ˆ"ï¼Œå°±åƒä¸ºæ¯ä¸ª"é¡¾å®¢"å®šåˆ¶ä¸“å±çš„æŠ¤ç†æ–¹æ¡ˆä¸€æ ·ã€‚

è®°ä½ï¼šå¥½çš„å›¾åƒå¢å¼ºå°±åƒæ˜¯ä¸€ä¸ªç»éªŒä¸°å¯Œçš„"ç¾å®¹å¸ˆ"ï¼Œæ—¢è¦è®©ç…§ç‰‡å˜å¾—æ›´ç¾ï¼Œåˆè¦ä¿æŒè‡ªç„¶ï¼âœ¨

## å‚è€ƒèµ„æ–™

1. Gonzalez R C, Woods R E. Digital Image Processing[M]. 4th Edition
2. OpenCVå®˜æ–¹æ–‡æ¡£: https://docs.opencv.org/
3. æ›´å¤šèµ„æº: [IP101é¡¹ç›®ä¸»é¡µ](https://github.com/GlimmerLab/IP101)