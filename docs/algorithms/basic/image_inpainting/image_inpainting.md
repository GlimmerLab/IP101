# å›¾åƒä¿®å¤æŠ€æœ¯è¯¦è§£ ğŸ¨

> å›¾åƒä¿®å¤å°±åƒæ˜¯æ•°å­—ä¸–ç•Œçš„"ä¿®å¤åŒ "ï¼é€šè¿‡å„ç§"ä¿®å¤æŠ€æœ¯"ï¼Œæˆ‘ä»¬å¯ä»¥è®©å—æŸçš„å›¾åƒé‡è·æ–°ç”Ÿï¼Œå°±åƒä¿®å¤åŒ ä¿®å¤ç ´æŸçš„è‰ºæœ¯å“ä¸€æ ·ã€‚è®©æˆ‘ä»¬ä¸€èµ·æ¥æ¢ç´¢è¿™ä¸ªç¥å¥‡çš„å›¾åƒ"ä¿®å¤å·¥ä½œå®¤"å§ï¼

## ç›®å½•
- [1. ä»€ä¹ˆæ˜¯å›¾åƒä¿®å¤ï¼Ÿ](#1-ä»€ä¹ˆæ˜¯å›¾åƒä¿®å¤)
- [2. åŸºäºæ‰©æ•£çš„ä¿®å¤](#2-åŸºäºæ‰©æ•£çš„ä¿®å¤)
- [3. åŸºäºå—åŒ¹é…çš„ä¿®å¤](#3-åŸºäºå—åŒ¹é…çš„ä¿®å¤)
- [4. åŸºäºPatchMatchçš„ä¿®å¤](#4-åŸºäºpatchmatchçš„ä¿®å¤)
- [5. åŸºäºæ·±åº¦å­¦ä¹ çš„ä¿®å¤](#5-åŸºäºæ·±åº¦å­¦ä¹ çš„ä¿®å¤)
- [6. è§†é¢‘ä¿®å¤](#6-è§†é¢‘ä¿®å¤)
- [7. ä»£ç å®ç°ä¸ä¼˜åŒ–](#7-ä»£ç å®ç°ä¸ä¼˜åŒ–)
- [8. å®éªŒç»“æœä¸åˆ†æ](#8-å®éªŒç»“æœä¸åˆ†æ)

## 1. ä»€ä¹ˆæ˜¯å›¾åƒä¿®å¤ï¼Ÿ

å›¾åƒä¿®å¤å°±åƒæ˜¯æ•°å­—ä¸–ç•Œçš„"ä¿®å¤åŒ "ï¼Œä¸»è¦ç›®çš„æ˜¯ï¼š
- ğŸ¨ ä¿®å¤å›¾åƒç¼ºå¤±ï¼ˆå°±åƒå¡«è¡¥ç”»ä½œçš„ç ´æŸï¼‰
- ğŸ–Œï¸ å»é™¤ä¸éœ€è¦çš„å…ƒç´ ï¼ˆå°±åƒæ¸…é™¤ç”»ä½œçš„æ±¡æ¸ï¼‰
- ğŸ” æ¢å¤å›¾åƒç»†èŠ‚ï¼ˆå°±åƒä¿®å¤ç”»ä½œçš„ç»†èŠ‚ï¼‰
- ğŸ“¸ æå‡å›¾åƒè´¨é‡ï¼ˆå°±åƒè®©ç”»ä½œç„•ç„¶ä¸€æ–°ï¼‰

å¸¸è§çš„ä¿®å¤æ–¹æ³•åŒ…æ‹¬ï¼š
- åŸºäºæ‰©æ•£çš„ä¿®å¤ï¼ˆæœ€åŸºç¡€çš„"ä¿®å¤å·¥å…·"ï¼‰
- åŸºäºå—åŒ¹é…çš„ä¿®å¤ï¼ˆæ™ºèƒ½"æ‹¼å›¾"ä¿®å¤ï¼‰
- åŸºäºPatchMatchçš„ä¿®å¤ï¼ˆå¿«é€Ÿ"åŒ¹é…"ä¿®å¤ï¼‰
- åŸºäºæ·±åº¦å­¦ä¹ çš„ä¿®å¤ï¼ˆAI"æ™ºèƒ½"ä¿®å¤ï¼‰
- è§†é¢‘ä¿®å¤ï¼ˆåŠ¨æ€"ä¿®å¤"æŠ€æœ¯ï¼‰

## 2. åŸºäºæ‰©æ•£çš„ä¿®å¤

æƒ³è±¡ä¸€ä¸‹ï¼Œå½“ä½ åœ¨æ²™æ»©ä¸Šç”»äº†ä¸€ä¸ªå›¾æ¡ˆï¼Œæµ·æµªä¼šæ…¢æ…¢æŠŠå›¾æ¡ˆè¾¹ç¼˜çš„æ²™å­å†²èµ°ï¼Œè¿™ä¸ªè¿‡ç¨‹å°±åƒæ‰©æ•£ä¿®å¤ï¼æ‰©æ•£ä¿®å¤æ³•é€šè¿‡å°†å·²çŸ¥åŒºåŸŸçš„åƒç´ å€¼é€æ¸"æ‰©æ•£"åˆ°æœªçŸ¥åŒºåŸŸï¼Œå®ç°å›¾åƒä¿®å¤ã€‚

### ç®—æ³•åŸç†

æ‰©æ•£ä¿®å¤åŸºäºåå¾®åˆ†æ–¹ç¨‹(PDE)ç†è®ºï¼Œä¸»è¦ä½¿ç”¨ä»¥ä¸‹æ–¹ç¨‹ï¼š

1. å„å‘åŒæ€§æ‰©æ•£æ–¹ç¨‹ï¼š
$$
\frac{\partial I}{\partial t} = \nabla^2 I
$$

2. å„å‘å¼‚æ€§æ‰©æ•£æ–¹ç¨‹ï¼š
$$
\frac{\partial I}{\partial t} = \nabla \cdot (c(|\nabla I|)\nabla I)
$$

å…¶ä¸­ï¼š
- $I$ æ˜¯å›¾åƒå¼ºåº¦
- $t$ æ˜¯æ—¶é—´å‚æ•°
- $\nabla$ æ˜¯æ¢¯åº¦ç®—å­
- $c(|\nabla I|)$ æ˜¯æ‰©æ•£ç³»æ•°å‡½æ•°

### ä»£ç å®ç°
```cpp
Mat diffusion_inpaint(
    const Mat& src,      // è¾“å…¥å›¾åƒ
    const Mat& mask,     // ä¿®å¤åŒºåŸŸæ©ç 
    int radius,          // æ‰©æ•£åŠå¾„
    int num_iterations)  // è¿­ä»£æ¬¡æ•°
{
    Mat result = src.clone();
    Mat mask_float;
    mask.convertTo(mask_float, CV_32F, 1.0/255.0);

    // è¿­ä»£æ‰©æ•£
    for(int iter = 0; iter < num_iterations; iter++) {
        Mat next = result.clone();

        #pragma omp parallel for
        for(int i = radius; i < result.rows-radius; i++) {
            for(int j = radius; j < result.cols-radius; j++) {
                if(mask.at<uchar>(i,j) > 0) {
                    Vec3f sum(0,0,0);
                    float weight_sum = 0;

                    // åœ¨é‚»åŸŸå†…è¿›è¡Œæ‰©æ•£
                    for(int di = -radius; di <= radius; di++) {
                        for(int dj = -radius; dj <= radius; dj++) {
                            if(di == 0 && dj == 0) continue;

                            Point pt(j+dj, i+di);
                            if(mask.at<uchar>(pt) == 0) {
                                float w = 1.0f / (abs(di) + abs(dj));
                                sum += Vec3f(result.at<Vec3b>(pt)) * w;
                                weight_sum += w;
                            }
                        }
                    }

                    if(weight_sum > EPSILON) {
                        sum /= weight_sum;
                        next.at<Vec3b>(i,j) = Vec3b(sum);
                    }
                }
            }
        }

        result = next;
    }

    return result;
}
```

## 3. åŸºäºå—åŒ¹é…çš„ä¿®å¤

è¿™å°±åƒæ˜¯æ‹¼å›¾æ¸¸æˆï¼æˆ‘ä»¬åœ¨å›¾åƒä¸­å¯»æ‰¾ä¸ç¼ºå¤±åŒºåŸŸæœ€ç›¸ä¼¼çš„å›¾åƒå—ï¼Œç„¶åæŠŠå®ƒ"æ‹¼"åˆ°ç¼ºå¤±åŒºåŸŸã€‚è¿™ç§æ–¹æ³•ç‰¹åˆ«é€‚åˆä¿®å¤æœ‰é‡å¤çº¹ç†çš„åŒºåŸŸã€‚

### ç®—æ³•åŸç†

å—åŒ¹é…ä¿®å¤åŸºäºä»¥ä¸‹æ•°å­¦åŸç†ï¼š

1. å—ç›¸ä¼¼åº¦åº¦é‡ï¼š
$$
d(p,q) = \sum_{i=1}^{n} \sum_{j=1}^{m} \|I_p(i,j) - I_q(i,j)\|^2
$$

2. æœ€ä½³åŒ¹é…å—é€‰æ‹©ï¼š
$$
p^* = \arg\min_{p \in \Omega} d(p,q)
$$

å…¶ä¸­ï¼š
- $p$ æ˜¯å¾…ä¿®å¤å—
- $q$ æ˜¯å€™é€‰å—
- $\Omega$ æ˜¯å·²çŸ¥åŒºåŸŸ
- $I_p(i,j)$ æ˜¯å—påœ¨ä½ç½®(i,j)çš„åƒç´ å€¼

### ä»£ç å®ç°
```cpp
Mat patch_match_inpaint(
    const Mat& src,       // è¾“å…¥å›¾åƒ
    const Mat& mask,      // ä¿®å¤åŒºåŸŸæ©ç 
    int patch_size,       // å—å¤§å°
    int search_area)      // æœç´¢èŒƒå›´
{
    Mat result = src.clone();
    int half_patch = patch_size / 2;

    // è·å–éœ€è¦ä¿®å¤çš„ç‚¹
    vector<Point> inpaint_points;
    for(int i = half_patch; i < mask.rows-half_patch; i++) {
        for(int j = half_patch; j < mask.cols-half_patch; j++) {
            if(mask.at<uchar>(i,j) > 0) {
                inpaint_points.push_back(Point(j,i));
            }
        }
    }

    // å¯¹æ¯ä¸ªéœ€è¦ä¿®å¤çš„ç‚¹æ‰¾æœ€ä½³åŒ¹é…å—
    #pragma omp parallel for
    for(int k = 0; k < static_cast<int>(inpaint_points.size()); k++) {
        Point p = inpaint_points[k];
        double min_dist = numeric_limits<double>::max();
        Point best_match;

        // åœ¨æœç´¢åŒºåŸŸå†…å¯»æ‰¾æœ€ä½³åŒ¹é…
        for(int i = max(half_patch, p.y-search_area);
            i < min(src.rows-half_patch, p.y+search_area); i++) {
            for(int j = max(half_patch, p.x-search_area);
                j < min(src.cols-half_patch, p.x+search_area); j++) {
                if(mask.at<uchar>(i,j) == 0) {
                    double dist = compute_patch_similarity(
                        src, src, p, Point(j,i), patch_size);
                    if(dist < min_dist) {
                        min_dist = dist;
                        best_match = Point(j,i);
                    }
                }
            }
        }

        // å¤åˆ¶æœ€ä½³åŒ¹é…å—
        if(min_dist < numeric_limits<double>::max()) {
            for(int di = -half_patch; di <= half_patch; di++) {
                for(int dj = -half_patch; dj <= half_patch; dj++) {
                    Point src_pt = best_match + Point(dj,di);
                    Point dst_pt = p + Point(dj,di);
                    if(mask.at<uchar>(dst_pt) > 0) {
                        result.at<Vec3b>(dst_pt) = src.at<Vec3b>(src_pt);
                    }
                }
            }
        }
    }

    return result;
}
```

## 4. åŸºäºPatchMatchçš„ä¿®å¤

PatchMatchç®—æ³•å°±åƒæ˜¯"å¿«é€Ÿæ‹¼å›¾"ï¼å®ƒé€šè¿‡éšæœºæœç´¢å’Œä¼ æ’­å¿«é€Ÿæ‰¾åˆ°æœ€ä½³åŒ¹é…ï¼Œå¤§å¤§æé«˜äº†å—åŒ¹é…çš„æ•ˆç‡ã€‚

### ç®—æ³•åŸç†

PatchMatchç®—æ³•åŸºäºä»¥ä¸‹æ•°å­¦åŸç†ï¼š

1. éšæœºåˆå§‹åŒ–ï¼š
$$
\phi_0(x) = \text{random offset}
$$

2. ä¼ æ’­æ­¥éª¤ï¼š
$$
\phi_n(x) = \arg\min_{\phi \in \{\phi_n(x), \phi_n(x-1), \phi_n(x+1)\}} d(x, x+\phi)
$$

3. éšæœºæœç´¢ï¼š
$$
\phi_n(x) = \arg\min_{\phi \in \{\phi_n(x), \phi_{random}\}} d(x, x+\phi)
$$

å…¶ä¸­ï¼š
- $\phi(x)$ æ˜¯åç§»åœº
- $d(x,y)$ æ˜¯å—ç›¸ä¼¼åº¦åº¦é‡
- $n$ æ˜¯è¿­ä»£æ¬¡æ•°

### ä»£ç å®ç°
```cpp
Mat patchmatch_inpaint(
    const Mat& src,       // è¾“å…¥å›¾åƒ
    const Mat& mask,      // ä¿®å¤åŒºåŸŸæ©ç 
    int patch_size,       // å—å¤§å°
    int num_iterations)   // è¿­ä»£æ¬¡æ•°
{
    Mat result = src.clone();
    int half_patch = patch_size / 2;

    // åˆå§‹åŒ–éšæœºåŒ¹é…
    RNG rng;
    Mat offsets(mask.size(), CV_32SC2);
    for(int i = 0; i < mask.rows; i++) {
        for(int j = 0; j < mask.cols; j++) {
            if(mask.at<uchar>(i,j) > 0) {
                int dx = rng.uniform(0, src.cols);
                int dy = rng.uniform(0, src.rows);
                offsets.at<Vec2i>(i,j) = Vec2i(dx-j, dy-i);
            }
        }
    }

    // è¿­ä»£ä¼˜åŒ–
    for(int iter = 0; iter < num_iterations; iter++) {
        // ä¼ æ’­
        for(int i = 0; i < mask.rows; i++) {
            for(int j = 0; j < mask.cols; j++) {
                if(mask.at<uchar>(i,j) > 0) {
                    // æ£€æŸ¥ç›¸é‚»åƒç´ çš„åŒ¹é…
                    vector<Point> neighbors = {
                        Point(j-1,i), Point(j+1,i),
                        Point(j,i-1), Point(j,i+1)
                    };

                    for(const auto& n : neighbors) {
                        if(n.x >= 0 && n.x < mask.cols &&
                           n.y >= 0 && n.y < mask.rows) {
                            Vec2i offset = offsets.at<Vec2i>(n);
                            Point match = Point(j+offset[0], i+offset[1]);

                            if(match.x >= 0 && match.x < src.cols &&
                               match.y >= 0 && match.y < src.rows) {
                                double dist = compute_patch_similarity(
                                    src, src, Point(j,i), match, patch_size);
                                Vec2i currOffset = offsets.at<Vec2i>(i,j);
                                Point currMatch(j+currOffset[0], i+currOffset[1]);
                                if(dist < compute_patch_similarity(
                                    src, src, Point(j,i), currMatch, patch_size)) {
                                    offsets.at<Vec2i>(i,j) = offset;
                                }
                            }
                        }
                    }
                }
            }
        }

        // éšæœºæœç´¢
        for(int i = 0; i < mask.rows; i++) {
            for(int j = 0; j < mask.cols; j++) {
                if(mask.at<uchar>(i,j) > 0) {
                    int searchRadius = src.cols;
                    while(searchRadius > 1) {
                        int dx = rng.uniform(-searchRadius, searchRadius);
                        int dy = rng.uniform(-searchRadius, searchRadius);
                        Point match(j+dx, i+dy);

                        if(match.x >= 0 && match.x < src.cols &&
                           match.y >= 0 && match.y < src.rows) {
                            double dist = compute_patch_similarity(
                                src, src, Point(j,i), match, patch_size);
                            Vec2i currOffset = offsets.at<Vec2i>(i,j);
                            Point currMatch(j+currOffset[0], i+currOffset[1]);
                            if(dist < compute_patch_similarity(
                                src, src, Point(j,i), currMatch, patch_size)) {
                                offsets.at<Vec2i>(i,j) = Vec2i(dx, dy);
                            }
                        }
                        searchRadius /= 2;
                    }
                }
            }
        }
    }

    // åº”ç”¨æœ€ä½³åŒ¹é…
    for(int i = 0; i < mask.rows; i++) {
        for(int j = 0; j < mask.cols; j++) {
            if(mask.at<uchar>(i,j) > 0) {
                Vec2i offset = offsets.at<Vec2i>(i,j);
                Point match(j+offset[0], i+offset[1]);
                if(match.x >= 0 && match.x < src.cols &&
                   match.y >= 0 && match.y < src.rows) {
                    result.at<Vec3b>(i,j) = src.at<Vec3b>(match);
                }
            }
        }
    }

    return result;
}
```

## 5. åŸºäºæ·±åº¦å­¦ä¹ çš„ä¿®å¤

æ·±åº¦å­¦ä¹ ä¿®å¤å°±åƒæ˜¯è®­ç»ƒä¸€ä¸ª"æ™ºèƒ½ä¿®å¤å¸ˆ"ï¼é€šè¿‡å­¦ä¹ å¤§é‡å›¾åƒï¼Œç½‘ç»œå¯ä»¥ç†è§£å›¾åƒçš„ç»“æ„å’Œå†…å®¹ï¼Œä»è€Œç”Ÿæˆæ›´è‡ªç„¶çš„ä¿®å¤ç»“æœã€‚

### ç®—æ³•åŸç†

æ·±åº¦å­¦ä¹ ä¿®å¤åŸºäºä»¥ä¸‹æ•°å­¦åŸç†ï¼š

1. ç”Ÿæˆå™¨æŸå¤±å‡½æ•°ï¼š
$$
L_{gen} = L_{recon} + \lambda_{adv}L_{adv} + \lambda_{per}L_{per}
$$

2. é‡å»ºæŸå¤±ï¼š
$$
L_{recon} = \|G(x) - y\|_1
$$

3. å¯¹æŠ—æŸå¤±ï¼š
$$
L_{adv} = \mathbb{E}_{x\sim p_{data}}[\log D(x)] + \mathbb{E}_{z\sim p_z}[\log(1-D(G(z)))]
$$

4. æ„ŸçŸ¥æŸå¤±ï¼š
$$
L_{per} = \sum_{i=1}^N \frac{1}{C_iH_iW_i}\|\phi_i(G(x)) - \phi_i(y)\|_1
$$

å…¶ä¸­ï¼š
- $G$ æ˜¯ç”Ÿæˆå™¨
- $D$ æ˜¯åˆ¤åˆ«å™¨
- $\phi_i$ æ˜¯é¢„è®­ç»ƒç½‘ç»œçš„ç‰¹å¾æå–å™¨
- $\lambda_{adv}$ å’Œ $\lambda_{per}$ æ˜¯æƒé‡ç³»æ•°

### ä»£ç å®ç°
```cpp
class InpaintingNet {
private:
    // ç¼–ç å™¨
    vector<ConvLayer> encoder;
    // è§£ç å™¨
    vector<DeconvLayer> decoder;
    // æ³¨æ„åŠ›æ¨¡å—
    AttentionModule attention;
    // åˆ¤åˆ«å™¨
    Discriminator discriminator;

public:
    InpaintingNet() {
        // åˆå§‹åŒ–ç½‘ç»œç»“æ„
        initialize_network();
    }

    Mat forward(const Mat& image, const Mat& mask) {
        // ç¼–ç 
        vector<Mat> features;
        Mat x = image;
        for(const auto& layer : encoder) {
            x = layer.forward(x);
            features.push_back(x);
        }

        // æ³¨æ„åŠ›æœºåˆ¶
        x = attention.forward(x, mask);

        // è§£ç 
        for(int i = 0; i < decoder.size(); i++) {
            x = decoder[i].forward(x);
            if(i < features.size()) {
                x = concat(x, features[features.size()-1-i]);
            }
        }

        return x;
    }

    void train(const Mat& image, const Mat& mask) {
        // å‰å‘ä¼ æ’­
        Mat output = forward(image, mask);

        // è®¡ç®—é‡å»ºæŸå¤±
        float reconstruction_loss = compute_reconstruction_loss(output, image);

        // è®¡ç®—å¯¹æŠ—æŸå¤±
        float adversarial_loss = discriminator.compute_loss(output, image);

        // è®¡ç®—æ„ŸçŸ¥æŸå¤±
        float perceptual_loss = compute_perceptual_loss(output, image);

        // æ€»æŸå¤±
        float total_loss = reconstruction_loss +
                          0.1 * adversarial_loss +
                          0.1 * perceptual_loss;

        // åå‘ä¼ æ’­
        backward(total_loss);
    }
};
```

## 6. è§†é¢‘ä¿®å¤

è§†é¢‘ä¿®å¤å°±åƒæ˜¯"åŠ¨æ€ä¿®å¤"ï¼éœ€è¦è€ƒè™‘æ—¶é—´ç»´åº¦çš„è¿ç»­æ€§ï¼Œç¡®ä¿ä¿®å¤ç»“æœåœ¨æ—¶é—´ä¸Šä¿æŒå¹³æ»‘ã€‚

### ç®—æ³•åŸç†

è§†é¢‘ä¿®å¤åŸºäºä»¥ä¸‹æ•°å­¦åŸç†ï¼š

1. å…‰æµæ–¹ç¨‹ï¼š
$$
I_xu + I_yv + I_t = 0
$$

2. æ—¶ç©ºä¸€è‡´æ€§çº¦æŸï¼š
$$
E_{temporal} = \sum_{t=1}^{T-1} \|I_t - I_{t+1}\|^2
$$

3. ç©ºé—´å¹³æ»‘çº¦æŸï¼š
$$
E_{spatial} = \sum_{t=1}^T \|\nabla I_t\|^2
$$

å…¶ä¸­ï¼š
- $I_x, I_y, I_t$ æ˜¯å›¾åƒåœ¨xã€yæ–¹å‘å’Œæ—¶é—´ä¸Šçš„æ¢¯åº¦
- $u, v$ æ˜¯å…‰æµåœº
- $T$ æ˜¯è§†é¢‘å¸§æ•°

### ä»£ç å®ç°
```cpp
vector<Mat> video_inpaint(
    const vector<Mat>& frames,     // è¾“å…¥è§†é¢‘å¸§
    const vector<Mat>& masks,      // æ¯å¸§çš„ä¿®å¤æ©ç 
    int patch_size,                // å—å¤§å°
    int num_iterations)            // è¿­ä»£æ¬¡æ•°
{
    vector<Mat> results;
    for(const auto& frame : frames) {
        results.push_back(frame.clone());
    }
    int half_patch = patch_size / 2;

    // è®¡ç®—å…‰æµåœº
    vector<Mat> flow_forward, flow_backward;
    for(size_t i = 0; i < frames.size()-1; i++) {
        Mat flow;
        calcOpticalFlowFarneback(frames[i], frames[i+1], flow,
                               0.5, 3, 15, 3, 5, 1.2, 0);
        flow_forward.push_back(flow);
    }

    for(size_t i = frames.size()-1; i > 0; i--) {
        Mat flow;
        calcOpticalFlowFarneback(frames[i], frames[i-1], flow,
                               0.5, 3, 15, 3, 5, 1.2, 0);
        flow_backward.push_back(flow);
    }

    // è¿­ä»£ä¿®å¤
    for(int iter = 0; iter < num_iterations; iter++) {
        for(size_t t = 0; t < frames.size(); t++) {
            // è·å–æ—¶ç©ºé‚»åŸŸ
            vector<Mat> temporal_patches;
            if(t > 0) {
                Mat map1, map2;
                Mat& flow = flow_backward[t-1];
                convertMaps(flow, Mat(), map1, map2, CV_32FC1);
                Mat warped;
                remap(results[t-1], warped, map1, map2, INTER_LINEAR);
                temporal_patches.push_back(warped);
            }
            if(t < frames.size()-1) {
                Mat map1, map2;
                Mat& flow = flow_forward[t];
                convertMaps(flow, Mat(), map1, map2, CV_32FC1);
                Mat warped;
                remap(results[t+1], warped, map1, map2, INTER_LINEAR);
                temporal_patches.push_back(warped);
            }

            // ä¿®å¤å½“å‰å¸§
            for(int i = half_patch; i < frames[t].rows-half_patch; i++) {
                for(int j = half_patch; j < frames[t].cols-half_patch; j++) {
                    if(masks[t].at<uchar>(i,j) > 0) {
                        double min_dist = numeric_limits<double>::max();
                        Point best_match;

                        // ç©ºé—´åŒ¹é…
                        for(int di = -half_patch; di <= half_patch; di++) {
                            for(int dj = -half_patch; dj <= half_patch; dj++) {
                                if(masks[t].at<uchar>(i+di,j+dj) == 0) {
                                    double dist = compute_patch_similarity(
                                        results[t], results[t],
                                        Point(j,i), Point(j+dj,i+di), patch_size);
                                    if(dist < min_dist) {
                                        min_dist = dist;
                                        best_match = Point(j+dj,i+di);
                                    }
                                }
                            }
                        }

                        // æ—¶é—´åŒ¹é…
                        for(const auto& patch : temporal_patches) {
                            for(int di = -half_patch; di <= half_patch; di++) {
                                for(int dj = -half_patch; dj <= half_patch; dj++) {
                                    Point pt(j+dj, i+di);
                                    if(pt.x >= 0 && pt.x < patch.cols &&
                                       pt.y >= 0 && pt.y < patch.rows) {
                                        double dist = compute_patch_similarity(
                                            results[t], patch,
                                            Point(j,i), pt, patch_size);
                                        if(dist < min_dist) {
                                            min_dist = dist;
                                            best_match = pt;
                                        }
                                    }
                                }
                            }
                        }

                        // åº”ç”¨æœ€ä½³åŒ¹é…
                        if(min_dist < numeric_limits<double>::max()) {
                            results[t].at<Vec3b>(i,j) =
                                results[t].at<Vec3b>(best_match);
                        }
                    }
                }
            }
        }
    }

    return results;
}
```

## 7. ä»£ç å®ç°ä¸ä¼˜åŒ–

### 7.1 å¹¶è¡Œè®¡ç®—ä¼˜åŒ–
- ä½¿ç”¨OpenMPè¿›è¡Œå¹¶è¡Œè®¡ç®—
- åˆç†è®¾ç½®çº¿ç¨‹æ•°
- é¿å…çº¿ç¨‹ç«äº‰

### 7.2 å†…å­˜ä¼˜åŒ–
- ä½¿ç”¨è¿ç»­å†…å­˜
- é¿å…é¢‘ç¹çš„å†…å­˜åˆ†é…
- ä½¿ç”¨å†…å­˜æ± 

### 7.3 ç®—æ³•ä¼˜åŒ–
- ä½¿ç”¨æŸ¥æ‰¾è¡¨
- å‡å°‘é‡å¤è®¡ç®—
- ä½¿ç”¨SIMDæŒ‡ä»¤

### 7.4 ç®—æ³•é€‰æ‹©å»ºè®®
- æ ¹æ®ä¿®å¤åŒºåŸŸå¤§å°é€‰æ‹©
- è€ƒè™‘å›¾åƒå¤æ‚åº¦
- æƒè¡¡è´¨é‡å’Œé€Ÿåº¦

## 8. å®éªŒç»“æœä¸åˆ†æ

### 8.1 ä¿®å¤æ•ˆæœå¯¹æ¯”
- ä¸åŒç®—æ³•çš„ä¿®å¤æ•ˆæœå¯¹æ¯”
- ä¸åŒåœºæ™¯ä¸‹çš„é€‚ç”¨æ€§åˆ†æ
- ä¿®å¤è´¨é‡è¯„ä¼°

### 8.2 æ€§èƒ½åˆ†æ
- è®¡ç®—æ—¶é—´å¯¹æ¯”
- å†…å­˜å ç”¨åˆ†æ
- ä¼˜åŒ–æ•ˆæœè¯„ä¼°

### 8.3 åº”ç”¨æ¡ˆä¾‹
- è€ç…§ç‰‡ä¿®å¤æ¡ˆä¾‹
- æ°´å°å»é™¤æ¡ˆä¾‹
- è§†é¢‘ä¿®å¤æ¡ˆä¾‹

## æ€»ç»“

å›¾åƒä¿®å¤å°±åƒæ˜¯æ•°å­—ä¸–ç•Œçš„"ä¿®å¤åŒ "ï¼é€šè¿‡åŸºäºæ‰©æ•£ã€å—åŒ¹é…ã€PatchMatchå’Œæ·±åº¦å­¦ä¹ çš„"ä¿®å¤æŠ€æœ¯"ï¼Œæˆ‘ä»¬å¯ä»¥è®©å—æŸçš„å›¾åƒé‡è·æ–°ç”Ÿã€‚åœ¨å®é™…åº”ç”¨ä¸­ï¼Œéœ€è¦æ ¹æ®å…·ä½“æƒ…å†µé€‰æ‹©åˆé€‚çš„"ä¿®å¤æ–¹æ¡ˆ"ï¼Œå°±åƒä¿®å¤åŒ ä¸ºæ¯ä»¶è‰ºæœ¯å“åˆ¶å®šä¸“å±çš„ä¿®å¤è®¡åˆ’ä¸€æ ·ã€‚

è®°ä½ï¼šå¥½çš„å›¾åƒä¿®å¤å°±åƒæ˜¯ä¸€ä¸ªç»éªŒä¸°å¯Œçš„"ä¿®å¤åŒ "ï¼Œæ—¢è¦ç²¾ç¡®ä¿®å¤ï¼Œåˆè¦ä¿æŒå›¾åƒçš„è‡ªç„¶æ€§ï¼ğŸ¨

## å‚è€ƒèµ„æ–™

1. Bertalmio M, et al. Image inpainting[C]. SIGGRAPH, 2000
2. Barnes C, et al. PatchMatch: A randomized correspondence algorithm for structural image editing[J]. TOG, 2009
3. Yu J, et al. Free-form image inpainting with gated convolution[C]. ICCV, 2019
4. Liu G, et al. Image inpainting for irregular holes using partial convolutions[C]. ECCV, 2018
5. OpenCVå®˜æ–¹æ–‡æ¡£: https://docs.opencv.org/
6. æ›´å¤šèµ„æº: [IP101é¡¹ç›®ä¸»é¡µ](https://github.com/GlimmerLab/IP101)