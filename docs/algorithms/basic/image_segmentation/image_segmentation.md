# å›¾åƒåˆ†å‰²è¯¦è§£ âœ‚ï¸

> æ¬¢è¿æ¥åˆ°å›¾åƒå¤„ç†çš„"æ‰‹æœ¯å®¤"ï¼åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•åƒå¤–ç§‘åŒ»ç”Ÿä¸€æ ·ç²¾å‡†åœ°"åˆ‡å‰²"å›¾åƒã€‚è®©æˆ‘ä»¬ä¸€èµ·æ¢ç´¢è¿™ä¸ªç¥å¥‡çš„å›¾åƒ"æ‰‹æœ¯"ä¸–ç•Œå§ï¼ğŸ¥

## ç›®å½• ğŸ“‘
- [1. å›¾åƒåˆ†å‰²ç®€ä»‹](#1-å›¾åƒåˆ†å‰²ç®€ä»‹)
- [2. é˜ˆå€¼åˆ†å‰²ï¼šæœ€åŸºç¡€çš„"æ‰‹æœ¯åˆ€"](#2-é˜ˆå€¼åˆ†å‰²æœ€åŸºç¡€çš„æ‰‹æœ¯åˆ€)
- [3. Kå‡å€¼åˆ†å‰²ï¼šæ™ºèƒ½"åˆ†ç±»æ‰‹æœ¯"](#3-kå‡å€¼åˆ†å‰²æ™ºèƒ½åˆ†ç±»æ‰‹æœ¯)
- [4. åŒºåŸŸç”Ÿé•¿ï¼šç»„ç»‡æ‰©å¼ æ‰‹æœ¯](#4-åŒºåŸŸç”Ÿé•¿ç»„ç»‡æ‰©å¼ æ‰‹æœ¯)
- [5. åˆ†æ°´å²­åˆ†å‰²ï¼šåœ°å½¢åˆ†å‰²æ‰‹æœ¯](#5-åˆ†æ°´å²­åˆ†å‰²åœ°å½¢åˆ†å‰²æ‰‹æœ¯)
- [6. å›¾å‰²åˆ†å‰²ï¼šç½‘ç»œåˆ‡å‰²æ‰‹æœ¯](#6-å›¾å‰²åˆ†å‰²ç½‘ç»œåˆ‡å‰²æ‰‹æœ¯)
- [7. å®éªŒæ•ˆæœä¸åº”ç”¨](#7-å®éªŒæ•ˆæœä¸åº”ç”¨)
- [8. æ€§èƒ½ä¼˜åŒ–ä¸æ³¨æ„äº‹é¡¹](#8-æ€§èƒ½ä¼˜åŒ–ä¸æ³¨æ„äº‹é¡¹)

## 1. å›¾åƒåˆ†å‰²ç®€ä»‹ ğŸ¯

### 1.1 ä»€ä¹ˆæ˜¯å›¾åƒåˆ†å‰²ï¼Ÿ

å›¾åƒåˆ†å‰²å°±åƒæ˜¯ç»™å›¾åƒåš"æ‰‹æœ¯åˆ†åŒº"ï¼Œä¸»è¦ç›®çš„æ˜¯ï¼š
- âœ‚ï¸ åˆ†ç¦»ä¸åŒåŒºåŸŸï¼ˆå°±åƒåˆ†ç¦»ä¸åŒå™¨å®˜ï¼‰
- ğŸ¯ è¯†åˆ«ç›®æ ‡å¯¹è±¡ï¼ˆå°±åƒå®šä½æ‰‹æœ¯éƒ¨ä½ï¼‰
- ğŸ” æå–æ„Ÿå…´è¶£åŒºåŸŸï¼ˆå°±åƒå–å‡ºç—…å˜ç»„ç»‡ï¼‰
- ğŸ“Š åˆ†æå›¾åƒç»“æ„ï¼ˆå°±åƒè¿›è¡Œç»„ç»‡æ£€æŸ¥ï¼‰

### 1.2 ä¸ºä»€ä¹ˆéœ€è¦å›¾åƒåˆ†å‰²ï¼Ÿ

- ğŸ‘€ åŒ»å­¦å›¾åƒåˆ†æï¼ˆå™¨å®˜å®šä½ã€è‚¿ç˜¤æ£€æµ‹ï¼‰
- ğŸ› ï¸ å·¥ä¸šæ£€æµ‹ï¼ˆç¼ºé™·æ£€æµ‹ã€é›¶ä»¶åˆ†å‰²ï¼‰
- ğŸŒ é¥æ„Ÿå›¾åƒåˆ†æï¼ˆåœ°ç‰©åˆ†ç±»ã€å»ºç­‘ç‰©æå–ï¼‰
- ğŸ‘ï¸ è®¡ç®—æœºè§†è§‰ï¼ˆç›®æ ‡æ£€æµ‹ã€åœºæ™¯ç†è§£ï¼‰

å¸¸è§çš„åˆ†å‰²æ–¹æ³•åŒ…æ‹¬ï¼š
- é˜ˆå€¼åˆ†å‰²ï¼ˆæœ€åŸºç¡€çš„"æ‰‹æœ¯åˆ€"ï¼‰
- Kå‡å€¼åˆ†å‰²ï¼ˆæ™ºèƒ½"åˆ†ç±»æ‰‹æœ¯"ï¼‰
- åŒºåŸŸç”Ÿé•¿ï¼ˆ"ç»„ç»‡æ‰©å¼ "æ‰‹æœ¯ï¼‰
- åˆ†æ°´å²­åˆ†å‰²ï¼ˆ"åœ°å½¢åˆ†å‰²"æ‰‹æœ¯ï¼‰
- å›¾å‰²åˆ†å‰²ï¼ˆ"ç½‘ç»œåˆ‡å‰²"æ‰‹æœ¯ï¼‰

## 2. é˜ˆå€¼åˆ†å‰²ï¼šæœ€åŸºç¡€çš„"æ‰‹æœ¯åˆ€" ğŸ”ª

### 2.1 åŸºæœ¬åŸç†

é˜ˆå€¼åˆ†å‰²å°±åƒæ˜¯ç”¨ä¸€æŠŠ"é­”æ³•æ‰‹æœ¯åˆ€"ï¼Œæ ¹æ®åƒç´ çš„"äº®åº¦"æ¥å†³å®šåˆ‡è¿˜æ˜¯ä¸åˆ‡ã€‚

æ•°å­¦è¡¨è¾¾å¼ï¼š
$$
g(x,y) = \begin{cases}
1, & f(x,y) > T \\
0, & f(x,y) \leq T
\end{cases}
$$

å…¶ä¸­ï¼š
- $f(x,y)$ æ˜¯è¾“å…¥å›¾åƒ
- $g(x,y)$ æ˜¯åˆ†å‰²ç»“æœ
- $T$ æ˜¯é˜ˆå€¼ï¼ˆ"æ‰‹æœ¯åˆ€"çš„åˆ‡å‰²æ·±åº¦ï¼‰

### 2.2 å¸¸è§æ–¹æ³•

1. å…¨å±€é˜ˆå€¼ï¼š
   - å›ºå®šé˜ˆå€¼ï¼ˆç»Ÿä¸€çš„"åˆ‡å‰²æ·±åº¦"ï¼‰
   - Otsuæ–¹æ³•ï¼ˆè‡ªåŠ¨æ‰¾æœ€ä½³"åˆ‡å‰²æ·±åº¦"ï¼‰

2. å±€éƒ¨é˜ˆå€¼ï¼š
   - è‡ªé€‚åº”é˜ˆå€¼ï¼ˆæ ¹æ®å±€éƒ¨åŒºåŸŸè°ƒæ•´"åˆ‡å‰²æ·±åº¦"ï¼‰
   - åŠ¨æ€é˜ˆå€¼ï¼ˆå®æ—¶è°ƒæ•´"æ‰‹æœ¯åˆ€"ï¼‰

### 2.3 å®ç°æ­¥éª¤

1. é¢„å¤„ç†ï¼š
   - è½¬æ¢ä¸ºç°åº¦å›¾
   - å™ªå£°å»é™¤
   - ç›´æ–¹å›¾å‡è¡¡åŒ–

2. é˜ˆå€¼è®¡ç®—ï¼š
   - æ‰‹åŠ¨è®¾ç½®
   - è‡ªåŠ¨è®¡ç®—ï¼ˆOtsuç­‰ï¼‰

3. åˆ†å‰²å¤„ç†ï¼š
   - äºŒå€¼åŒ–
   - åå¤„ç†ä¼˜åŒ–

### 2.4 æ‰‹åŠ¨å®ç°

#### C++å®ç°
```cpp
void threshold_segmentation(const Mat& src, Mat& dst,
                          double threshold, double max_val,
                          int type) {
    CV_Assert(!src.empty());

    // è½¬æ¢ä¸ºç°åº¦å›¾
    Mat gray;
    if (src.channels() == 3) {
        cvtColor(src, gray, COLOR_BGR2GRAY);
    } else {
        gray = src.clone();
    }

    dst.create(gray.size(), CV_8UC1);

    // ä½¿ç”¨OpenMPå¹¶è¡Œå¤„ç†
    #pragma omp parallel for
    for (int y = 0; y < gray.rows; y++) {
        for (int x = 0; x < gray.cols; x++) {
            uchar pixel = gray.at<uchar>(y, x);
            switch (type) {
                case THRESH_BINARY:
                    dst.at<uchar>(y, x) = pixel > threshold ? static_cast<uchar>(max_val) : 0;
                    break;
                case THRESH_BINARY_INV:
                    dst.at<uchar>(y, x) = pixel > threshold ? 0 : static_cast<uchar>(max_val);
                    break;
                case THRESH_TRUNC:
                    dst.at<uchar>(y, x) = pixel > threshold ? static_cast<uchar>(threshold) : pixel;
                    break;
                case THRESH_TOZERO:
                    dst.at<uchar>(y, x) = pixel > threshold ? pixel : 0;
                    break;
                case THRESH_TOZERO_INV:
                    dst.at<uchar>(y, x) = pixel > threshold ? 0 : pixel;
                    break;
            }
        }
    }
}
```

#### Pythonå®ç°
```python
def threshold_segmentation(img_path, method='otsu'):
    """
    é˜ˆå€¼åˆ†å‰²
    ä½¿ç”¨å¤šç§é˜ˆå€¼æ–¹æ³•è¿›è¡Œå›¾åƒåˆ†å‰²

    å‚æ•°:
        img_path: è¾“å…¥å›¾åƒè·¯å¾„
        method: é˜ˆå€¼æ–¹æ³•ï¼Œå¯é€‰'otsu', 'adaptive', 'triangle'

    è¿”å›:
        åˆ†å‰²ç»“æœå›¾åƒ
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path)
    if img is None:
        raise ValueError(f"æ— æ³•è¯»å–å›¾åƒ: {img_path}")

    # è½¬æ¢ä¸ºç°åº¦å›¾
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    if method == 'otsu':
        # Otsué˜ˆå€¼åˆ†å‰²
        _, result = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    elif method == 'adaptive':
        # è‡ªé€‚åº”é˜ˆå€¼åˆ†å‰²
        result = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                     cv2.THRESH_BINARY, 11, 2)
    elif method == 'triangle':
        # ä¸‰è§’å½¢é˜ˆå€¼åˆ†å‰²
        _, result = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_TRIANGLE)
    else:
        raise ValueError(f"ä¸æ”¯æŒçš„é˜ˆå€¼æ–¹æ³•: {method}")

    return cv2.cvtColor(result, cv2.COLOR_GRAY2BGR)

def compute_threshold_manual(image, threshold=127, max_val=255, thresh_type='binary'):
    """æ‰‹åŠ¨å®ç°é˜ˆå€¼åˆ†å‰²

    å‚æ•°:
        image: è¾“å…¥å›¾åƒ
        threshold: é˜ˆå€¼
        max_val: æœ€å¤§å€¼
        thresh_type: é˜ˆå€¼ç±»å‹ï¼Œå¯é€‰'binary', 'binary_inv', 'trunc', 'tozero', 'tozero_inv'

    è¿”å›:
        åˆ†å‰²åçš„å›¾åƒ
    """
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    result = np.zeros_like(gray)

    if thresh_type == 'binary':
        result[gray > threshold] = max_val
    elif thresh_type == 'binary_inv':
        result[gray <= threshold] = max_val
    elif thresh_type == 'trunc':
        result = np.minimum(gray, threshold)
    elif thresh_type == 'tozero':
        result = np.where(gray > threshold, gray, 0)
    elif thresh_type == 'tozero_inv':
        result = np.where(gray <= threshold, gray, 0)
    else:
        raise ValueError(f"ä¸æ”¯æŒçš„é˜ˆå€¼ç±»å‹: {thresh_type}")

    return result
```

## 3. Kå‡å€¼åˆ†å‰²ï¼šæ™ºèƒ½"åˆ†ç±»æ‰‹æœ¯" ğŸ¯

### 3.1 åŸºæœ¬åŸç†

Kå‡å€¼åˆ†å‰²å°±åƒæ˜¯ç»™å›¾åƒåš"åˆ†ç±»æ‰‹æœ¯"ï¼Œå°†ç›¸ä¼¼çš„åƒç´ "ç¼åˆ"åœ¨ä¸€èµ·ã€‚

æ•°å­¦è¡¨è¾¾å¼ï¼š
$$
J = \sum_{j=1}^k \sum_{i=1}^{n_j} \|x_i^{(j)} - c_j\|^2
$$

å…¶ä¸­ï¼š
- $k$ æ˜¯åˆ†ç±»æ•°é‡ï¼ˆ"æ‰‹æœ¯åŒºåŸŸ"æ•°é‡ï¼‰
- $x_i^{(j)}$ æ˜¯ç¬¬jç±»ä¸­çš„ç¬¬iä¸ªåƒç´ 
- $c_j$ æ˜¯ç¬¬jç±»çš„ä¸­å¿ƒï¼ˆ"æ‰‹æœ¯åŒºåŸŸ"ä¸­å¿ƒï¼‰

### 3.2 å®ç°æ­¥éª¤

1. åˆå§‹åŒ–ä¸­å¿ƒï¼š
   - éšæœºé€‰æ‹©kä¸ªä¸­å¿ƒï¼ˆé€‰æ‹©"æ‰‹æœ¯ç‚¹"ï¼‰
   - å¯ä»¥ä½¿ç”¨ä¼˜åŒ–çš„åˆå§‹åŒ–æ–¹æ³•

2. è¿­ä»£ä¼˜åŒ–ï¼š
   - åˆ†é…åƒç´ åˆ°æœ€è¿‘ä¸­å¿ƒï¼ˆåˆ’åˆ†"æ‰‹æœ¯åŒºåŸŸ"ï¼‰
   - æ›´æ–°ä¸­å¿ƒä½ç½®ï¼ˆè°ƒæ•´"æ‰‹æœ¯ç‚¹"ï¼‰
   - é‡å¤ç›´åˆ°æ”¶æ•›

### 3.3 ä¼˜åŒ–æ–¹æ³•

1. åŠ é€Ÿæ”¶æ•›ï¼š
   - K-means++
   - Mini-batch K-means

2. å¹¶è¡Œè®¡ç®—ï¼š
   - OpenMP
   - GPUåŠ é€Ÿ

### 3.4 æ‰‹åŠ¨å®ç°

#### C++å®ç°
```cpp
void kmeans_segmentation(const Mat& src, Mat& dst,
                        int k, int max_iter) {
    CV_Assert(!src.empty() && src.channels() == 3);

    // å°†å›¾åƒè½¬æ¢ä¸ºæµ®ç‚¹æ•°æ®
    Mat data;
    src.convertTo(data, CV_32F);
    data = data.reshape(1, src.rows * src.cols);

    // éšæœºåˆå§‹åŒ–èšç±»ä¸­å¿ƒ
    std::vector<Vec3f> centers(k);
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, src.rows * src.cols - 1);
    for (int i = 0; i < k; i++) {
        int idx = dis(gen);
        centers[i] = Vec3f(data.at<float>(idx, 0),
                          data.at<float>(idx, 1),
                          data.at<float>(idx, 2));
    }

    // Kå‡å€¼è¿­ä»£
    std::vector<int> labels(src.rows * src.cols);
    for (int iter = 0; iter < max_iter; iter++) {
        // åˆ†é…æ ‡ç­¾
        #pragma omp parallel for
        for (int i = 0; i < src.rows * src.cols; i++) {
            float min_dist = FLT_MAX;
            int min_center = 0;
            Vec3f pixel(data.at<float>(i, 0),
                       data.at<float>(i, 1),
                       data.at<float>(i, 2));

            for (int j = 0; j < k; j++) {
                float dist = static_cast<float>(norm(pixel - centers[j]));
                if (dist < min_dist) {
                    min_dist = dist;
                    min_center = j;
                }
            }
            labels[i] = min_center;
        }

        // æ›´æ–°èšç±»ä¸­å¿ƒ
        std::vector<Vec3f> new_centers(k, Vec3f(0, 0, 0));
        std::vector<int> counts(k, 0);

        #pragma omp parallel for
        for (int i = 0; i < src.rows * src.cols; i++) {
            int label = labels[i];
            Vec3f pixel(data.at<float>(i, 0),
                       data.at<float>(i, 1),
                       data.at<float>(i, 2));

            #pragma omp atomic
            new_centers[label][0] += pixel[0];
            #pragma omp atomic
            new_centers[label][1] += pixel[1];
            #pragma omp atomic
            new_centers[label][2] += pixel[2];
            #pragma omp atomic
            counts[label]++;
        }

        for (int i = 0; i < k; i++) {
            if (counts[i] > 0) {
                centers[i] = new_centers[i] / counts[i];
            }
        }
    }

    // ç”Ÿæˆç»“æœå›¾åƒ
    dst.create(src.size(), CV_8UC3);
    #pragma omp parallel for
    for (int i = 0; i < src.rows * src.cols; i++) {
        int y = i / src.cols;
        int x = i % src.cols;
        Vec3f center = centers[labels[i]];
        dst.at<Vec3b>(y, x) = Vec3b(saturate_cast<uchar>(center[0]),
                                   saturate_cast<uchar>(center[1]),
                                   saturate_cast<uchar>(center[2]));
    }
}
```

#### Pythonå®ç°
```python
def kmeans_segmentation(img_path, k=3):
    """
    Kå‡å€¼åˆ†å‰²
    ä½¿ç”¨Kå‡å€¼èšç±»è¿›è¡Œå›¾åƒåˆ†å‰²

    å‚æ•°:
        img_path: è¾“å…¥å›¾åƒè·¯å¾„
        k: èšç±»æ•°é‡ï¼Œé»˜è®¤ä¸º3

    è¿”å›:
        åˆ†å‰²ç»“æœå›¾åƒ
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path)
    if img is None:
        raise ValueError(f"æ— æ³•è¯»å–å›¾åƒ: {img_path}")

    # å°†å›¾åƒè½¬æ¢ä¸ºç‰¹å¾å‘é‡
    pixels = img.reshape((-1, 3))
    pixels = np.float32(pixels)

    # å®šä¹‰Kå‡å€¼çš„ç»ˆæ­¢æ¡ä»¶
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.2)

    # åº”ç”¨Kå‡å€¼èšç±»
    _, labels, centers = cv2.kmeans(pixels, k, None, criteria, 10, cv2.KMEANS_RANDOM_CENTERS)

    # å°†èšç±»ä¸­å¿ƒè½¬æ¢ä¸ºuint8ç±»å‹
    centers = np.uint8(centers)

    # é‡å»ºå›¾åƒ
    result = centers[labels.flatten()]
    result = result.reshape(img.shape)

    return result

def compute_kmeans_manual(image, k=3, max_iters=100):
    """æ‰‹åŠ¨å®ç°Kå‡å€¼åˆ†å‰²

    å‚æ•°:
        image: è¾“å…¥å›¾åƒ
        k: èšç±»æ•°é‡ï¼Œé»˜è®¤3
        max_iters: æœ€å¤§è¿­ä»£æ¬¡æ•°ï¼Œé»˜è®¤100

    è¿”å›:
        segmented: åˆ†å‰²åçš„å›¾åƒ
    """
    if len(image.shape) != 3:
        raise ValueError("è¾“å…¥å›¾åƒå¿…é¡»æ˜¯RGBå›¾åƒ")

    # å°†å›¾åƒè½¬æ¢ä¸ºç‰¹å¾å‘é‡
    height, width = image.shape[:2]
    pixels = image.reshape((-1, 3)).astype(np.float32)

    # éšæœºåˆå§‹åŒ–èšç±»ä¸­å¿ƒ
    centers = pixels[np.random.choice(pixels.shape[0], k, replace=False)]

    # è¿­ä»£ä¼˜åŒ–
    for _ in range(max_iters):
        old_centers = centers.copy()

        # è®¡ç®—æ¯ä¸ªåƒç´ åˆ°ä¸­å¿ƒçš„è·ç¦»
        distances = np.sqrt(((pixels[:, np.newaxis] - centers) ** 2).sum(axis=2))

        # åˆ†é…æ ‡ç­¾
        labels = np.argmin(distances, axis=1)

        # æ›´æ–°ä¸­å¿ƒ
        for i in range(k):
            mask = labels == i
            if np.any(mask):
                centers[i] = pixels[mask].mean(axis=0)

        # æ£€æŸ¥æ”¶æ•›
        if np.allclose(old_centers, centers, rtol=1e-3):
            break

    # é‡å»ºå›¾åƒ
    result = centers[labels].reshape(image.shape)
    return result.astype(np.uint8)
```

## 4. åŒºåŸŸç”Ÿé•¿ï¼šç»„ç»‡æ‰©å¼ æ‰‹æœ¯ ğŸ”ª

### 4.1 åŸºæœ¬åŸç†

åŒºåŸŸç”Ÿé•¿å°±åƒæ˜¯è¿›è¡Œ"ç»„ç»‡æ‰©å¼ "æ‰‹æœ¯ï¼Œä»ä¸€ä¸ªç§å­ç‚¹å¼€å§‹ï¼Œé€æ­¥"ç”Ÿé•¿"åˆ°ç›¸ä¼¼çš„åŒºåŸŸã€‚

ç”Ÿé•¿å‡†åˆ™ï¼š
$$
|I(x,y) - I(x_s,y_s)| \leq T
$$

å…¶ä¸­ï¼š
- $I(x,y)$ æ˜¯å½“å‰åƒç´ 
- $I(x_s,y_s)$ æ˜¯ç§å­ç‚¹
- $T$ æ˜¯ç”Ÿé•¿é˜ˆå€¼ï¼ˆ"ç›¸ä¼¼åº¦é˜ˆå€¼"ï¼‰

### 4.2 å®ç°æŠ€å·§

1. ç§å­ç‚¹é€‰æ‹©ï¼š
   - æ‰‹åŠ¨é€‰æ‹©ï¼ˆæŒ‡å®š"æ‰‹æœ¯èµ·ç‚¹"ï¼‰
   - è‡ªåŠ¨é€‰æ‹©ï¼ˆæ™ºèƒ½å®šä½"æ‰‹æœ¯ç‚¹"ï¼‰

2. ç”Ÿé•¿ç­–ç•¥ï¼š
   - 4é‚»åŸŸç”Ÿé•¿ï¼ˆä¸Šä¸‹å·¦å³æ‰©å¼ ï¼‰
   - 8é‚»åŸŸç”Ÿé•¿ï¼ˆå…¨æ–¹ä½æ‰©å¼ ï¼‰

### 4.3 ä¼˜åŒ–æ–¹æ³•

1. å¹¶è¡Œå¤„ç†ï¼š
   - å¤šçº¿ç¨‹åŒºåŸŸç”Ÿé•¿
   - GPUåŠ é€Ÿ

2. å†…å­˜ä¼˜åŒ–ï¼š
   - ä½¿ç”¨ä½å›¾å­˜å‚¨
   - é˜Ÿåˆ—ä¼˜åŒ–

### 4.4 æ‰‹åŠ¨å®ç°

#### C++å®ç°
```cpp
void region_growing(const Mat& src, Mat& dst,
                   const std::vector<Point>& seed_points,
                   double threshold) {
    CV_Assert(!src.empty() && !seed_points.empty());

    // åˆå§‹åŒ–ç»“æœå›¾åƒ
    dst = Mat::zeros(src.size(), CV_8UC1);

    // å¤„ç†æ¯ä¸ªç§å­ç‚¹
    for (const auto& seed : seed_points) {
        if (dst.at<uchar>(seed) > 0) continue;  // è·³è¿‡å·²å¤„ç†çš„ç‚¹

        std::queue<Point> points;
        points.push(seed);
        dst.at<uchar>(seed) = 255;

        Vec3b seed_color = src.at<Vec3b>(seed);

        while (!points.empty()) {
            Point current = points.front();
            points.pop();

            // æ£€æŸ¥8é‚»åŸŸ
            for (int dy = -1; dy <= 1; dy++) {
                for (int dx = -1; dx <= 1; dx++) {
                    Point neighbor(current.x + dx, current.y + dy);

                    if (neighbor.x >= 0 && neighbor.x < src.cols &&
                        neighbor.y >= 0 && neighbor.y < src.rows &&
                        dst.at<uchar>(neighbor) == 0) {

                        Vec3b neighbor_color = src.at<Vec3b>(neighbor);
                        double distance = colorDistance(seed_color, neighbor_color);

                        if (distance <= threshold) {
                            points.push(neighbor);
                            dst.at<uchar>(neighbor) = 255;
                        }
                    }
                }
            }
        }
    }
}
```

#### Pythonå®ç°
```python
def region_growing(img_path, seed_point=None, threshold=30):
    """
    åŒºåŸŸç”Ÿé•¿
    ä½¿ç”¨åŒºåŸŸç”Ÿé•¿æ–¹æ³•è¿›è¡Œå›¾åƒåˆ†å‰²

    å‚æ•°:
        img_path: è¾“å…¥å›¾åƒè·¯å¾„
        seed_point: ç§å­ç‚¹åæ ‡(x,y)ï¼Œé»˜è®¤ä¸ºå›¾åƒä¸­å¿ƒ
        threshold: ç”Ÿé•¿é˜ˆå€¼ï¼Œé»˜è®¤ä¸º30

    è¿”å›:
        åˆ†å‰²ç»“æœå›¾åƒ
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path)
    if img is None:
        raise ValueError(f"æ— æ³•è¯»å–å›¾åƒ: {img_path}")

    # å¦‚æœæœªæŒ‡å®šç§å­ç‚¹ï¼Œä½¿ç”¨å›¾åƒä¸­å¿ƒ
    if seed_point is None:
        h, w = img.shape[:2]
        seed_point = (w//2, h//2)

    # åˆ›å»ºæ ‡è®°å›¾åƒ
    mask = np.zeros(img.shape[:2], np.uint8)

    # è·å–ç§å­ç‚¹çš„é¢œè‰²
    seed_color = img[seed_point[1], seed_point[0]]

    # å®šä¹‰8é‚»åŸŸ
    neighbors = [(0,1), (1,0), (0,-1), (-1,0),
                (1,1), (-1,-1), (-1,1), (1,-1)]

    # åˆ›å»ºå¾…å¤„ç†ç‚¹é˜Ÿåˆ—
    stack = [seed_point]
    mask[seed_point[1], seed_point[0]] = 255

    while stack:
        x, y = stack.pop()
        for dx, dy in neighbors:
            nx, ny = x + dx, y + dy
            if (0 <= nx < img.shape[1] and 0 <= ny < img.shape[0] and
                mask[ny, nx] == 0 and
                np.all(np.abs(img[ny, nx] - seed_color) < threshold)):
                mask[ny, nx] = 255
                stack.append((nx, ny))

    # åº”ç”¨æ©ç 
    result = img.copy()
    result[mask == 0] = 0

    return result

def compute_region_growing_manual(image, seed_point=None, threshold=30):
    """æ‰‹åŠ¨å®ç°åŒºåŸŸç”Ÿé•¿åˆ†å‰²

    å‚æ•°:
        image: è¾“å…¥å›¾åƒ
        seed_point: ç§å­ç‚¹åæ ‡(x,y)ï¼Œé»˜è®¤ä¸ºå›¾åƒä¸­å¿ƒ
        threshold: ç”Ÿé•¿é˜ˆå€¼ï¼Œé»˜è®¤ä¸º30

    è¿”å›:
        åˆ†å‰²åçš„å›¾åƒ
    """
    if len(image.shape) != 3:
        raise ValueError("è¾“å…¥å¿…é¡»æ˜¯RGBå›¾åƒ")

    # å¦‚æœæœªæŒ‡å®šç§å­ç‚¹ï¼Œä½¿ç”¨å›¾åƒä¸­å¿ƒ
    if seed_point is None:
        h, w = image.shape[:2]
        seed_point = (w//2, h//2)

    # åˆ›å»ºæ ‡è®°å›¾åƒ
    mask = np.zeros(image.shape[:2], np.uint8)

    # è·å–ç§å­ç‚¹çš„é¢œè‰²
    seed_color = image[seed_point[1], seed_point[0]]

    # å®šä¹‰8é‚»åŸŸ
    neighbors = [(0,1), (1,0), (0,-1), (-1,0),
                (1,1), (-1,-1), (-1,1), (1,-1)]

    # åˆ›å»ºå¾…å¤„ç†ç‚¹é˜Ÿåˆ—
    stack = [seed_point]
    mask[seed_point[1], seed_point[0]] = 255

    while stack:
        x, y = stack.pop()
        for dx, dy in neighbors:
            nx, ny = x + dx, y + dy
            if (0 <= nx < image.shape[1] and 0 <= ny < image.shape[0] and
                mask[ny, nx] == 0):
                # è®¡ç®—é¢œè‰²å·®å¼‚
                color_diff = np.abs(image[ny, nx] - seed_color)
                if np.all(color_diff < threshold):
                    mask[ny, nx] = 255
                    stack.append((nx, ny))

    # åº”ç”¨æ©ç 
    result = image.copy()
    result[mask == 0] = 0

    return result
```

## 5. åˆ†æ°´å²­åˆ†å‰²ï¼šåœ°å½¢åˆ†å‰²æ‰‹æœ¯ ğŸ”ª

### 5.1 åŸºæœ¬åŸç†

åˆ†æ°´å²­åˆ†å‰²å°±åƒæ˜¯åœ¨å›¾åƒçš„"åœ°å½¢å›¾"ä¸Šæ³¨æ°´ï¼Œæ°´ä½ä¸Šå‡æ—¶å½¢æˆçš„"åˆ†æ°´å²­"å°±æ˜¯åˆ†å‰²è¾¹ç•Œã€‚

ä¸»è¦æ­¥éª¤ï¼š
1. è®¡ç®—æ¢¯åº¦ï¼š
   $$
   \|\nabla f\| = \sqrt{(\frac{\partial f}{\partial x})^2 + (\frac{\partial f}{\partial y})^2}
   $$

2. æ ‡è®°åŒºåŸŸï¼š
   - ç¡®å®šå‰æ™¯æ ‡è®°ï¼ˆ"å±±è°·"ï¼‰
   - ç¡®å®šèƒŒæ™¯æ ‡è®°ï¼ˆ"å±±è„Š"ï¼‰

### 5.2 å®ç°æ–¹æ³•

1. ä¼ ç»Ÿåˆ†æ°´å²­ï¼š
   - åŸºäºå½¢æ€å­¦é‡å»º
   - å®¹æ˜“è¿‡åˆ†å‰²

2. æ ‡è®°æ§åˆ¶ï¼š
   - ä½¿ç”¨æ ‡è®°ç‚¹æ§åˆ¶åˆ†å‰²
   - é¿å…è¿‡åˆ†å‰²é—®é¢˜

### 5.3 ä¼˜åŒ–æŠ€å·§

1. é¢„å¤„ç†ä¼˜åŒ–ï¼š
   - æ¢¯åº¦è®¡ç®—ä¼˜åŒ–
   - æ ‡è®°æå–ä¼˜åŒ–

2. åå¤„ç†ä¼˜åŒ–ï¼š
   - åŒºåŸŸåˆå¹¶
   - è¾¹ç•Œå¹³æ»‘

### 5.4 æ‰‹åŠ¨å®ç°

#### C++å®ç°
```cpp
void watershed_segmentation(const Mat& src,
                          Mat& markers,
                          Mat& dst) {
    CV_Assert(!src.empty() && !markers.empty());

    // è½¬æ¢æ ‡è®°å›¾åƒä¸º32ä½æ•´æ•°
    Mat markers32;
    markers.convertTo(markers32, CV_32S);

    // åº”ç”¨åˆ†æ°´å²­ç®—æ³•
    watershed(src, markers32);

    // ç”Ÿæˆç»“æœå›¾åƒ
    dst = src.clone();
    for (int y = 0; y < markers32.rows; y++) {
        for (int x = 0; x < markers32.cols; x++) {
            int marker = markers32.at<int>(y, x);
            if (marker == -1) {  // è¾¹ç•Œ
                dst.at<Vec3b>(y, x) = Vec3b(0, 0, 255);
            }
        }
    }

    // æ›´æ–°æ ‡è®°å›¾åƒ
    markers32.convertTo(markers, CV_8U);
}
```

#### Pythonå®ç°
```python
def watershed_segmentation(img_path):
    """
    åˆ†æ°´å²­åˆ†å‰²
    ä½¿ç”¨åˆ†æ°´å²­ç®—æ³•è¿›è¡Œå›¾åƒåˆ†å‰²

    å‚æ•°:
        img_path: è¾“å…¥å›¾åƒè·¯å¾„

    è¿”å›:
        åˆ†å‰²ç»“æœå›¾åƒ
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path)
    if img is None:
        raise ValueError(f"æ— æ³•è¯»å–å›¾åƒ: {img_path}")

    # è½¬æ¢ä¸ºç°åº¦å›¾
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # ä½¿ç”¨Otsuç®—æ³•è¿›è¡ŒäºŒå€¼åŒ–
    _, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)

    # å™ªå£°å»é™¤
    kernel = np.ones((3,3), np.uint8)
    opening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel, iterations=2)

    # ç¡®å®šèƒŒæ™¯åŒºåŸŸ
    sure_bg = cv2.dilate(opening, kernel, iterations=3)

    # ç¡®å®šå‰æ™¯åŒºåŸŸ
    dist_transform = cv2.distanceTransform(opening, cv2.DIST_L2, 5)
    _, sure_fg = cv2.threshold(dist_transform, 0.7*dist_transform.max(), 255, 0)
    sure_fg = np.uint8(sure_fg)

    # æ‰¾åˆ°æœªçŸ¥åŒºåŸŸ
    unknown = cv2.subtract(sure_bg, sure_fg)

    # æ ‡è®°
    _, markers = cv2.connectedComponents(sure_fg)
    markers = markers + 1
    markers[unknown == 255] = 0

    # åº”ç”¨åˆ†æ°´å²­ç®—æ³•
    markers = cv2.watershed(img, markers)

    # æ ‡è®°è¾¹ç•Œ
    result = img.copy()
    result[markers == -1] = [0, 0, 255]  # çº¢è‰²æ ‡è®°è¾¹ç•Œ

    return result

def compute_watershed_manual(image):
    """æ‰‹åŠ¨å®ç°åˆ†æ°´å²­åˆ†å‰²

    å‚æ•°:
        image: è¾“å…¥RGBå›¾åƒ

    è¿”å›:
        åˆ†å‰²åçš„å›¾åƒ
    """
    # è½¬æ¢ä¸ºç°åº¦å›¾
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # ä½¿ç”¨Otsuç®—æ³•è¿›è¡ŒäºŒå€¼åŒ–
    _, binary = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)

    # å½¢æ€å­¦æ“ä½œå»é™¤å™ªå£°
    kernel = np.ones((3,3), np.uint8)
    opening = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel, iterations=2)

    # ç¡®å®šèƒŒæ™¯åŒºåŸŸ
    sure_bg = cv2.dilate(opening, kernel, iterations=3)

    # ç¡®å®šå‰æ™¯åŒºåŸŸ
    dist_transform = cv2.distanceTransform(opening, cv2.DIST_L2, 5)
    _, sure_fg = cv2.threshold(dist_transform, 0.7*dist_transform.max(), 255, 0)
    sure_fg = np.uint8(sure_fg)

    # æ‰¾åˆ°æœªçŸ¥åŒºåŸŸ
    unknown = cv2.subtract(sure_bg, sure_fg)

    # æ ‡è®°
    _, markers = cv2.connectedComponents(sure_fg)
    markers = markers + 1
    markers[unknown == 255] = 0

    # åº”ç”¨åˆ†æ°´å²­ç®—æ³•
    markers = cv2.watershed(image, markers)

    # ç”Ÿæˆç»“æœå›¾åƒ
    result = image.copy()
    result[markers == -1] = [0, 0, 255]  # çº¢è‰²æ ‡è®°è¾¹ç•Œ

    return result
```

## 6. å›¾å‰²åˆ†å‰²ï¼šç½‘ç»œåˆ‡å‰²æ‰‹æœ¯ ğŸ”ª

### 6.1 åŸºæœ¬åŸç†

å›¾å‰²åˆ†å‰²å°±åƒæ˜¯åœ¨å›¾åƒçš„"å…³ç³»ç½‘ç»œ"ä¸­å¯»æ‰¾æœ€ä½³çš„"åˆ‡å‰²è·¯å¾„"ã€‚

èƒ½é‡å‡½æ•°ï¼š
$$
E(L) = \sum_{p \in P} D_p(L_p) + \sum_{(p,q) \in N} V_{p,q}(L_p,L_q)
$$

å…¶ä¸­ï¼š
- $D_p(L_p)$ æ˜¯æ•°æ®é¡¹ï¼ˆåƒç´ ä¸æ ‡ç­¾çš„åŒ¹é…åº¦ï¼‰
- $V_{p,q}(L_p,L_q)$ æ˜¯å¹³æ»‘é¡¹ï¼ˆç›¸é‚»åƒç´ çš„å…³ç³»ï¼‰

### 6.2 ä¼˜åŒ–æ–¹æ³•

1. æœ€å°å‰²ç®—æ³•ï¼š
   - æ„å»ºå›¾æ¨¡å‹
   - å¯»æ‰¾æœ€å°å‰²

2. GrabCutç®—æ³•ï¼š
   - è¿­ä»£ä¼˜åŒ–
   - äº¤äº’å¼åˆ†å‰²

### 6.3 å®ç°æŠ€å·§

1. å›¾æ„å»ºï¼š
   - èŠ‚ç‚¹è¡¨ç¤º
   - è¾¹æƒé‡è®¡ç®—

2. ä¼˜åŒ–ç­–ç•¥ï¼š
   - æœ€å¤§æµ/æœ€å°å‰²
   - è¿­ä»£ä¼˜åŒ–

### 6.4 æ‰‹åŠ¨å®ç°

#### C++å®ç°
```cpp
void graph_cut_segmentation(const Mat& src, Mat& dst,
                          const Rect& rect) {
    CV_Assert(!src.empty());

    // åˆ›å»ºæ©ç 
    Mat mask = Mat::zeros(src.size(), CV_8UC1);
    mask(rect) = GC_PR_FGD;  // çŸ©å½¢åŒºåŸŸä½œä¸ºå¯èƒ½å‰æ™¯

    // åˆ›å»ºä¸´æ—¶æ•°ç»„
    Mat bgdModel, fgdModel;

    // åº”ç”¨GrabCutç®—æ³•
    grabCut(src, mask, rect, bgdModel, fgdModel, 5, GC_INIT_WITH_RECT);

    // ç”Ÿæˆç»“æœå›¾åƒ
    dst = src.clone();
    for (int y = 0; y < src.rows; y++) {
        for (int x = 0; x < src.cols; x++) {
            if (mask.at<uchar>(y, x) == GC_BGD ||
                mask.at<uchar>(y, x) == GC_PR_BGD) {
                dst.at<Vec3b>(y, x) = Vec3b(0, 0, 0);
            }
        }
    }
}
```

#### Pythonå®ç°
```python
def graph_cut_segmentation(img_path):
    """
    å›¾å‰²åˆ†å‰²
    ä½¿ç”¨å›¾å‰²ç®—æ³•è¿›è¡Œå›¾åƒåˆ†å‰²

    å‚æ•°:
        img_path: è¾“å…¥å›¾åƒè·¯å¾„

    è¿”å›:
        åˆ†å‰²ç»“æœå›¾åƒ
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path)
    if img is None:
        raise ValueError(f"æ— æ³•è¯»å–å›¾åƒ: {img_path}")

    # åˆ›å»ºæ©ç 
    mask = np.zeros(img.shape[:2], np.uint8)

    # å®šä¹‰çŸ©å½¢åŒºåŸŸ
    rect = (50, 50, img.shape[1]-100, img.shape[0]-100)

    # åˆå§‹åŒ–èƒŒæ™¯å’Œå‰æ™¯æ¨¡å‹
    bgdModel = np.zeros((1,65), np.float64)
    fgdModel = np.zeros((1,65), np.float64)

    # åº”ç”¨GrabCutç®—æ³•
    cv2.grabCut(img, mask, rect, bgdModel, fgdModel, 5, cv2.GC_INIT_WITH_RECT)

    # ä¿®æ”¹æ©ç 
    mask2 = np.where((mask==2)|(mask==0), 0, 1).astype('uint8')

    # åº”ç”¨æ©ç åˆ°å›¾åƒ
    result = img * mask2[:,:,np.newaxis]

    return result

def compute_graphcut_manual(image, rect=None):
    """æ‰‹åŠ¨å®ç°å›¾å‰²åˆ†å‰²

    å‚æ•°:
        image: è¾“å…¥RGBå›¾åƒ
        rect: çŸ©å½¢åŒºåŸŸ(x, y, width, height)ï¼Œå¦‚æœä¸ºNoneåˆ™ä½¿ç”¨ä¸­å¿ƒåŒºåŸŸ

    è¿”å›:
        åˆ†å‰²åçš„å›¾åƒ
    """
    if rect is None:
        h, w = image.shape[:2]
        margin = min(w, h) // 4
        rect = (margin, margin, w - 2*margin, h - 2*margin)

    # åˆ›å»ºæ©ç 
    mask = np.zeros(image.shape[:2], np.uint8)
    mask[rect[1]:rect[1]+rect[3], rect[0]:rect[0]+rect[2]] = cv2.GC_PR_FGD

    # åˆ›å»ºä¸´æ—¶æ•°ç»„
    bgd_model = np.zeros((1,65), np.float64)
    fgd_model = np.zeros((1,65), np.float64)

    # åº”ç”¨GrabCutç®—æ³•
    cv2.grabCut(image, mask, rect, bgd_model, fgd_model, 5, cv2.GC_INIT_WITH_RECT)

    # ç”Ÿæˆç»“æœå›¾åƒ
    mask2 = np.where((mask==2)|(mask==0), 0, 1).astype('uint8')
    result = image * mask2[:,:,np.newaxis]

    return result
```

## 7. å®éªŒæ•ˆæœä¸åº”ç”¨ ğŸ¯

### 7.1 åº”ç”¨åœºæ™¯

1. åŒ»å­¦å›¾åƒï¼š
   - å™¨å®˜åˆ†å‰²
   - è‚¿ç˜¤æ£€æµ‹
   - è¡€ç®¡æå–

2. é¥æ„Ÿå›¾åƒï¼š
   - åœ°ç‰©åˆ†ç±»
   - å»ºç­‘ç‰©æå–
   - é“è·¯æ£€æµ‹

3. å·¥ä¸šæ£€æµ‹ï¼š
   - ç¼ºé™·æ£€æµ‹
   - é›¶ä»¶åˆ†å‰²
   - å°ºå¯¸æµ‹é‡

### 7.2 æ³¨æ„äº‹é¡¹

1. åˆ†å‰²è¿‡ç¨‹æ³¨æ„ç‚¹ï¼š
   - é¢„å¤„ç†å¾ˆé‡è¦ï¼ˆæœ¯å‰å‡†å¤‡ï¼‰
   - å‚æ•°è¦é€‚å½“ï¼ˆæ‰‹æœ¯åŠ›åº¦ï¼‰
   - åå¤„ç†å¿…è¦ï¼ˆæœ¯åæŠ¤ç†ï¼‰

2. ç®—æ³•é€‰æ‹©å»ºè®®ï¼š
   - æ ¹æ®å›¾åƒç‰¹ç‚¹é€‰æ‹©
   - è€ƒè™‘å®æ—¶æ€§è¦æ±‚
   - æƒè¡¡ç²¾åº¦å’Œæ•ˆç‡

## 8. æ€§èƒ½ä¼˜åŒ–ä¸æ³¨æ„äº‹é¡¹ ğŸ”ª

### 8.1 æ€§èƒ½ä¼˜åŒ–æŠ€å·§

1. SIMDåŠ é€Ÿï¼š
```cpp
// ä½¿ç”¨AVX2åŠ é€Ÿé˜ˆå€¼åˆ†å‰²
inline void threshold_simd(const uchar* src, uchar* dst, int width, uchar thresh) {
    __m256i thresh_vec = _mm256_set1_epi8(thresh);
    for (int x = 0; x < width; x += 32) {
        __m256i pixels = _mm256_loadu_si256((__m256i*)(src + x));
        __m256i mask = _mm256_cmpgt_epi8(pixels, thresh_vec);
        _mm256_storeu_si256((__m256i*)(dst + x), mask);
    }
}
```

2. OpenMPå¹¶è¡ŒåŒ–ï¼š
```cpp
#pragma omp parallel for collapse(2)
for (int y = 0; y < height; y++) {
    for (int x = 0; x < width; x++) {
        // åˆ†å‰²å¤„ç†
    }
}
```

3. å†…å­˜ä¼˜åŒ–ï¼š
```cpp
// ä½¿ç”¨å†…å­˜å¯¹é½
alignas(32) uchar buffer[256];
```

### 8.2 æ³¨æ„äº‹é¡¹

1. åˆ†å‰²è¿‡ç¨‹æ³¨æ„ç‚¹ï¼š
   - é¢„å¤„ç†å¾ˆé‡è¦ï¼ˆæœ¯å‰å‡†å¤‡ï¼‰
   - å‚æ•°è¦é€‚å½“ï¼ˆæ‰‹æœ¯åŠ›åº¦ï¼‰
   - åå¤„ç†å¿…è¦ï¼ˆæœ¯åæŠ¤ç†ï¼‰

2. ç®—æ³•é€‰æ‹©å»ºè®®ï¼š
   - æ ¹æ®å›¾åƒç‰¹ç‚¹é€‰æ‹©
   - è€ƒè™‘å®æ—¶æ€§è¦æ±‚
   - æƒè¡¡ç²¾åº¦å’Œæ•ˆç‡

## æ€»ç»“ ğŸ¯

å›¾åƒåˆ†å‰²å°±åƒæ˜¯ç»™å›¾åƒåš"æ‰‹æœ¯"ï¼é€šè¿‡é˜ˆå€¼åˆ†å‰²ã€Kå‡å€¼åˆ†å‰²ã€åŒºåŸŸç”Ÿé•¿ã€åˆ†æ°´å²­åˆ†å‰²å’Œå›¾å‰²åˆ†å‰²ç­‰"æ‰‹æœ¯æ–¹æ³•"ï¼Œæˆ‘ä»¬å¯ä»¥ç²¾ç¡®åœ°åˆ†ç¦»å›¾åƒä¸­çš„ä¸åŒåŒºåŸŸã€‚åœ¨å®é™…åº”ç”¨ä¸­ï¼Œéœ€è¦æ ¹æ®å…·ä½“æƒ…å†µé€‰æ‹©åˆé€‚çš„"æ‰‹æœ¯æ–¹æ¡ˆ"ï¼Œå°±åƒåŒ»ç”Ÿä¸ºæ¯ä¸ªç—…äººåˆ¶å®šä¸“å±çš„æ‰‹æœ¯è®¡åˆ’ä¸€æ ·ã€‚

è®°ä½ï¼šå¥½çš„å›¾åƒåˆ†å‰²å°±åƒæ˜¯ä¸€ä¸ªç»éªŒä¸°å¯Œçš„"å¤–ç§‘åŒ»ç”Ÿ"ï¼Œæ—¢è¦ç²¾ç¡®åˆ†å‰²ï¼Œåˆè¦ä¿æŒåŒºåŸŸçš„å®Œæ•´æ€§ï¼ğŸ¥

## å‚è€ƒèµ„æ–™ ğŸ“š

1. Otsu N. A threshold selection method from gray-level histograms[J]. IEEE Trans. SMC, 1979
2. Meyer F. Color image segmentation[C]. ICIP, 1992
3. Boykov Y, et al. Fast approximate energy minimization via graph cuts[J]. PAMI, 2001
4. Rother C, et al. GrabCut: Interactive foreground extraction using iterated graph cuts[J]. TOG, 2004
5. OpenCVå®˜æ–¹æ–‡æ¡£: https://docs.opencv.org/
6. æ›´å¤šèµ„æº: [IP101é¡¹ç›®ä¸»é¡µ](https://github.com/GlimmerLab/IP101)
