# å›¾åƒåŒ¹é…æ¢ç´¢æŒ‡å— ğŸ§©

> å›¾åƒåŒ¹é…å°±åƒæ˜¯ç©"æ‰¾ä¸åŒ"æ¸¸æˆï¼æˆ‘ä»¬éœ€è¦åœ¨ä¸¤å¼ å›¾ç‰‡ä¸­æ‰¾åˆ°ç›¸ä¼¼çš„éƒ¨åˆ†ï¼Œå°±åƒæ˜¯åœ¨ç©æ‹¼å›¾ä¸€æ ·ã€‚è®©æˆ‘ä»¬ä¸€èµ·æ¥æ¢ç´¢è¿™ä¸ªæœ‰è¶£çš„å›¾åƒå¤„ç†é¢†åŸŸå§ï¼

## ç›®å½•
- [1. ä»€ä¹ˆæ˜¯å›¾åƒåŒ¹é…ï¼Ÿ](#1-ä»€ä¹ˆæ˜¯å›¾åƒåŒ¹é…)
- [2. æ¨¡æ¿åŒ¹é…(SSD)](#2-æ¨¡æ¿åŒ¹é…ssd)
- [3. æ¨¡æ¿åŒ¹é…(SAD)](#3-æ¨¡æ¿åŒ¹é…sad)
- [4. æ¨¡æ¿åŒ¹é…(NCC)](#4-æ¨¡æ¿åŒ¹é…ncc)
- [5. æ¨¡æ¿åŒ¹é…(ZNCC)](#5-æ¨¡æ¿åŒ¹é…zncc)
- [6. ç‰¹å¾ç‚¹åŒ¹é…](#6-ç‰¹å¾ç‚¹åŒ¹é…)
- [7. ä»£ç å®ç°ä¸ä¼˜åŒ–](#7-ä»£ç å®ç°ä¸ä¼˜åŒ–)
- [8. åº”ç”¨åœºæ™¯ä¸å®è·µ](#8-åº”ç”¨åœºæ™¯ä¸å®è·µ)

## 1. å›¾åƒåŒ¹é…ï¼šè®¡ç®—æœºçš„"æ‰¾ä¸åŒ"æ¸¸æˆ

æƒ³è±¡ä¸€ä¸‹ï¼Œä½ æ­£åœ¨ç©ä¸€ä¸ª"æ‰¾ä¸åŒ"æ¸¸æˆã€‚å›¾åƒåŒ¹é…å°±æ˜¯è¿™æ ·çš„è¿‡ç¨‹ï¼Œåªä¸è¿‡æ˜¯ç”±è®¡ç®—æœºæ¥å®Œæˆï¼å®ƒå¯ä»¥å¸®åŠ©æˆ‘ä»¬ï¼š

- ğŸ” åœ¨å›¾åƒä¸­å®šä½ç›®æ ‡ï¼ˆæ‰¾åˆ°"ä¸åŒ"çš„ä½ç½®ï¼‰
- ğŸ¯ è¿›è¡Œç›®æ ‡è·Ÿè¸ªï¼ˆè¿ç»­"æ‰¾ä¸åŒ"ï¼‰
- ğŸ“Š è®¡ç®—å›¾åƒç›¸ä¼¼åº¦ï¼ˆåˆ¤æ–­"ä¸åŒ"çš„ç¨‹åº¦ï¼‰
- ğŸ–¼ï¸ å›¾åƒæ‹¼æ¥ï¼ˆæŠŠ"ä¸åŒ"çš„éƒ¨åˆ†æ‹¼åœ¨ä¸€èµ·ï¼‰

å¸¸è§çš„åŒ¹é…æ–¹æ³•ï¼š
- ğŸ“ åŸºäºæ¨¡æ¿çš„åŒ¹é…ï¼ˆå›ºå®šæ¨¡æ¿ï¼‰
- ğŸ”‘ åŸºäºç‰¹å¾çš„åŒ¹é…ï¼ˆå…³é”®ç‚¹ï¼‰
- ğŸŒŠ åŸºäºåŒºåŸŸçš„åŒ¹é…ï¼ˆç›¸ä¼¼åŒºåŸŸï¼‰
- ğŸ§® åŸºäºå˜æ¢çš„åŒ¹é…ï¼ˆå‡ ä½•å˜æ¢ï¼‰

## 2. æ¨¡æ¿åŒ¹é…(SSD)ï¼šåƒç´ å·®çš„"å¹³æ–¹å’Œ"è®¡ç®—

### 2.1 åŸºæœ¬åŸç†

SSDï¼ˆSum of Squared Differencesï¼‰å°±åƒæ˜¯è®¡ç®—"åƒç´ å·®çš„å¹³æ–¹å’Œ"ï¼å®ƒé€šè¿‡æ¯”è¾ƒæ¨¡æ¿å’Œå›¾åƒå±€éƒ¨åŒºåŸŸçš„åƒç´ å·®å¼‚æ¥æ‰¾åˆ°æœ€ä½³åŒ¹é…ä½ç½®ã€‚

æ•°å­¦è¡¨è¾¾å¼ï¼š
$$
SSD(x,y) = \sum_{i,j} [T(i,j) - I(x+i,y+j)]^2
$$

å…¶ä¸­ï¼š
- $T(i,j)$ æ˜¯æ¨¡æ¿å›¾åƒåœ¨ä½ç½®$(i,j)$çš„åƒç´ å€¼
- $I(x+i,y+j)$ æ˜¯å¾…åŒ¹é…å›¾åƒåœ¨ä½ç½®$(x+i,y+j)$çš„åƒç´ å€¼

### 2.2 C++å®ç°

```cpp
// ä½¿ç”¨SIMDä¼˜åŒ–çš„SSDå®ç°
void compute_ssd_simd(const Mat& src, const Mat& templ, Mat& result) {
    int h = templ.rows;
    int w = templ.cols;
    int H = src.rows;
    int W = src.cols;

    result.create(H-h+1, W-w+1, CV_32F);
    result = Scalar(0);

    #pragma omp parallel for
    for (int y = 0; y < H-h+1; y++) {
        for (int x = 0; x < W-w+1; x++) {
            float sum = 0;
            for (int i = 0; i < h; i++) {
                const uchar* src_ptr = src.ptr<uchar>(y+i) + x;
                const uchar* templ_ptr = templ.ptr<uchar>(i);

                // ä½¿ç”¨AVX2è¿›è¡Œå‘é‡åŒ–è®¡ç®—
                for (int j = 0; j < w; j += 8) {
                    __m256i src_vec = _mm256_cvtepu8_epi32(_mm_loadl_epi64((__m128i*)(src_ptr+j)));
                    __m256i templ_vec = _mm256_cvtepu8_epi32(_mm_loadl_epi64((__m128i*)(templ_ptr+j)));
                    __m256i diff = _mm256_sub_epi32(src_vec, templ_vec);
                    __m256i square = _mm256_mullo_epi32(diff, diff);

                    float temp[8];
                    _mm256_storeu_ps(temp, _mm256_cvtepi32_ps(square));
                    for (int k = 0; k < 8 && j+k < w; k++) {
                        sum += temp[k];
                    }
                }
            }
            result.at<float>(y, x) = sum;
        }
    }
}
```

### 2.3 Pythonå®ç°

```python
def ssd_matching(img_path, template_path):
    """
    ä½¿ç”¨å¹³æ–¹å·®å’Œè¿›è¡Œæ¨¡æ¿åŒ¹é…
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
    template = cv2.imread(template_path, cv2.IMREAD_GRAYSCALE)
    if img is None or template is None:
        raise ValueError("æ— æ³•è¯»å–å›¾åƒ")

    h, w = template.shape
    H, W = img.shape
    result = np.zeros((H-h+1, W-w+1), dtype=np.float32)

    # è®¡ç®—SSD
    for y in range(H-h+1):
        for x in range(W-w+1):
            diff = img[y:y+h, x:x+w] - template
            result[y, x] = np.sum(diff * diff)

    # å½’ä¸€åŒ–ç»“æœ
    result = cv2.normalize(result, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)

    # æ‰¾åˆ°æœ€ä½³åŒ¹é…ä½ç½®
    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
    top_left = min_loc
    bottom_right = (top_left[0] + w, top_left[1] + h)

    # åœ¨åŸå›¾ä¸Šç»˜åˆ¶çŸ©å½¢æ¡†
    img_color = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
    cv2.rectangle(img_color, top_left, bottom_right, (0, 0, 255), 2)

    return img_color
```

## 3. æ¨¡æ¿åŒ¹é…(SAD)ï¼šåƒç´ å·®çš„"ç»å¯¹å€¼"è®¡ç®—

### 3.1 åŸºæœ¬åŸç†

SADï¼ˆSum of Absolute Differencesï¼‰å°±åƒæ˜¯è®¡ç®—"åƒç´ å·®çš„ç»å¯¹å€¼ä¹‹å’Œ"ï¼å®ƒæ¯”SSDè®¡ç®—æ›´å¿«ï¼Œä½†å¯¹å™ªå£°æ›´æ•æ„Ÿã€‚

æ•°å­¦è¡¨è¾¾å¼ï¼š
$$
SAD(x,y) = \sum_{i,j} |T(i,j) - I(x+i,y+j)|
$$

### 3.2 C++å®ç°

```cpp
// ä½¿ç”¨SIMDä¼˜åŒ–çš„SADå®ç°
void compute_sad_simd(const Mat& src, const Mat& templ, Mat& result) {
    int h = templ.rows;
    int w = templ.cols;
    int H = src.rows;
    int W = src.cols;

    result.create(H-h+1, W-w+1, CV_32F);
    result = Scalar(0);

    #pragma omp parallel for
    for (int y = 0; y < H-h+1; y++) {
        for (int x = 0; x < W-w+1; x++) {
            float sum = 0;
            for (int i = 0; i < h; i++) {
                const uchar* src_ptr = src.ptr<uchar>(y+i) + x;
                const uchar* templ_ptr = templ.ptr<uchar>(i);

                // ä½¿ç”¨AVX2è¿›è¡Œå‘é‡åŒ–è®¡ç®—
                for (int j = 0; j < w; j += 8) {
                    __m256i src_vec = _mm256_cvtepu8_epi32(_mm_loadl_epi64((__m128i*)(src_ptr+j)));
                    __m256i templ_vec = _mm256_cvtepu8_epi32(_mm_loadl_epi64((__m128i*)(templ_ptr+j)));
                    __m256i diff = _mm256_abs_epi32(_mm256_sub_epi32(src_vec, templ_vec));

                    float temp[8];
                    _mm256_storeu_ps(temp, _mm256_cvtepi32_ps(diff));
                    for (int k = 0; k < 8 && j+k < w; k++) {
                        sum += temp[k];
                    }
                }
            }
            result.at<float>(y, x) = sum;
        }
    }
}
```

### 3.3 Pythonå®ç°

```python
def sad_matching(img_path, template_path):
    """
    ä½¿ç”¨ç»å¯¹å·®å’Œè¿›è¡Œæ¨¡æ¿åŒ¹é…
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
    template = cv2.imread(template_path, cv2.IMREAD_GRAYSCALE)
    if img is None or template is None:
        raise ValueError("æ— æ³•è¯»å–å›¾åƒ")

    h, w = template.shape
    H, W = img.shape
    result = np.zeros((H-h+1, W-w+1), dtype=np.float32)

    # è®¡ç®—SAD
    for y in range(H-h+1):
        for x in range(W-w+1):
            diff = np.abs(img[y:y+h, x:x+w] - template)
            result[y, x] = np.sum(diff)

    # å½’ä¸€åŒ–ç»“æœ
    result = cv2.normalize(result, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)

    # æ‰¾åˆ°æœ€ä½³åŒ¹é…ä½ç½®
    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
    top_left = min_loc
    bottom_right = (top_left[0] + w, top_left[1] + h)

    # åœ¨åŸå›¾ä¸Šç»˜åˆ¶çŸ©å½¢æ¡†
    img_color = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
    cv2.rectangle(img_color, top_left, bottom_right, (0, 0, 255), 2)

    return img_color
```

## 4. æ¨¡æ¿åŒ¹é…(NCC)ï¼šå½’ä¸€åŒ–çš„"ç›¸å…³æ€§"è®¡ç®—

### 4.1 åŸºæœ¬åŸç†

NCCï¼ˆNormalized Cross Correlationï¼‰å°±åƒæ˜¯è®¡ç®—"å½’ä¸€åŒ–çš„ç›¸å…³æ€§"ï¼å®ƒå¯¹å…‰ç…§å˜åŒ–æ›´é²æ£’ã€‚

æ•°å­¦è¡¨è¾¾å¼ï¼š
$$
NCC(x,y) = \frac{\sum_{i,j} [T(i,j) - \mu_T][I(x+i,y+j) - \mu_I]}{\sqrt{\sum_{i,j} [T(i,j) - \mu_T]^2 \sum_{i,j} [I(x+i,y+j) - \mu_I]^2}}
$$

å…¶ä¸­ï¼š
- $\mu_T$ æ˜¯æ¨¡æ¿çš„å‡å€¼
- $\mu_I$ æ˜¯å›¾åƒå±€éƒ¨åŒºåŸŸçš„å‡å€¼

### 4.2 C++å®ç°

```cpp
// ä½¿ç”¨SIMDä¼˜åŒ–çš„NCCå®ç°
void compute_ncc_simd(const Mat& src, const Mat& templ, Mat& result) {
    int h = templ.rows;
    int w = templ.cols;
    int H = src.rows;
    int W = src.cols;

    result.create(H-h+1, W-w+1, CV_32F);
    result = Scalar(0);

    // è®¡ç®—æ¨¡æ¿çš„èŒƒæ•°
    float templ_norm = 0;
    for (int i = 0; i < h; i++) {
        const uchar* templ_ptr = templ.ptr<uchar>(i);
        for (int j = 0; j < w; j++) {
            templ_norm += templ_ptr[j] * templ_ptr[j];
        }
    }
    templ_norm = sqrt(templ_norm);

    #pragma omp parallel for
    for (int y = 0; y < H-h+1; y++) {
        for (int x = 0; x < W-w+1; x++) {
            float window_norm = 0;
            float dot_product = 0;

            for (int i = 0; i < h; i++) {
                const uchar* src_ptr = src.ptr<uchar>(y+i) + x;
                const uchar* templ_ptr = templ.ptr<uchar>(i);

                // ä½¿ç”¨AVX2è¿›è¡Œå‘é‡åŒ–è®¡ç®—
                for (int j = 0; j < w; j += 8) {
                    __m256i src_vec = _mm256_cvtepu8_epi32(_mm_loadl_epi64((__m128i*)(src_ptr+j)));
                    __m256i templ_vec = _mm256_cvtepu8_epi32(_mm_loadl_epi64((__m128i*)(templ_ptr+j)));

                    // è®¡ç®—ç‚¹ç§¯
                    __m256i product = _mm256_mullo_epi32(src_vec, templ_vec);
                    float temp[8];
                    _mm256_storeu_ps(temp, _mm256_cvtepi32_ps(product));
                    for (int k = 0; k < 8 && j+k < w; k++) {
                        dot_product += temp[k];
                    }

                    // è®¡ç®—çª—å£èŒƒæ•°
                    __m256i square = _mm256_mullo_epi32(src_vec, src_vec);
                    _mm256_storeu_ps(temp, _mm256_cvtepi32_ps(square));
                    for (int k = 0; k < 8 && j+k < w; k++) {
                        window_norm += temp[k];
                    }
                }
            }

            window_norm = sqrt(window_norm);
            if (window_norm > 0 && templ_norm > 0) {
                result.at<float>(y, x) = dot_product / (window_norm * templ_norm);
            }
        }
    }
}
```

### 4.3 Pythonå®ç°

```python
def ncc_matching(img_path, template_path):
    """
    ä½¿ç”¨å½’ä¸€åŒ–äº’ç›¸å…³è¿›è¡Œæ¨¡æ¿åŒ¹é…
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
    template = cv2.imread(template_path, cv2.IMREAD_GRAYSCALE)
    if img is None or template is None:
        raise ValueError("æ— æ³•è¯»å–å›¾åƒ")

    h, w = template.shape
    H, W = img.shape
    result = np.zeros((H-h+1, W-w+1), dtype=np.float32)

    # è®¡ç®—æ¨¡æ¿çš„èŒƒæ•°
    template_norm = np.sqrt(np.sum(template * template))

    # è®¡ç®—NCC
    for y in range(H-h+1):
        for x in range(W-w+1):
            window = img[y:y+h, x:x+w]
            window_norm = np.sqrt(np.sum(window * window))
            if window_norm > 0 and template_norm > 0:
                result[y, x] = np.sum(window * template) / (window_norm * template_norm)

    # å½’ä¸€åŒ–ç»“æœ
    result = cv2.normalize(result, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)

    # æ‰¾åˆ°æœ€ä½³åŒ¹é…ä½ç½®
    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
    top_left = max_loc  # NCCä½¿ç”¨æœ€å¤§å€¼
    bottom_right = (top_left[0] + w, top_left[1] + h)

    # åœ¨åŸå›¾ä¸Šç»˜åˆ¶çŸ©å½¢æ¡†
    img_color = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
    cv2.rectangle(img_color, top_left, bottom_right, (0, 0, 255), 2)

    return img_color
```

## 5. æ¨¡æ¿åŒ¹é…(ZNCC)ï¼šé›¶å‡å€¼çš„"ç›¸å…³æ€§"è®¡ç®—

### 5.1 åŸºæœ¬åŸç†

ZNCCï¼ˆZero-mean Normalized Cross Correlationï¼‰æ˜¯NCCçš„æ”¹è¿›ç‰ˆæœ¬ï¼Œå¯¹å…‰ç…§å’Œå¯¹æ¯”åº¦å˜åŒ–æ›´é²æ£’ã€‚

æ•°å­¦è¡¨è¾¾å¼ï¼š
$$
ZNCC(x,y) = \frac{\sum_{i,j} [T(i,j) - \mu_T][I(x+i,y+j) - \mu_I]}{\sigma_T \sigma_I}
$$

å…¶ä¸­ï¼š
- $\sigma_T$ æ˜¯æ¨¡æ¿çš„æ ‡å‡†å·®
- $\sigma_I$ æ˜¯å›¾åƒå±€éƒ¨åŒºåŸŸçš„æ ‡å‡†å·®

### 5.2 C++å®ç°

```cpp
// ä½¿ç”¨SIMDä¼˜åŒ–çš„ZNCCå®ç°
void compute_zncc_simd(const Mat& src, const Mat& templ, Mat& result) {
    int h = templ.rows;
    int w = templ.cols;
    int H = src.rows;
    int W = src.cols;

    result.create(H-h+1, W-w+1, CV_32F);
    result = Scalar(0);

    // è®¡ç®—æ¨¡æ¿çš„å‡å€¼å’Œæ ‡å‡†å·®
    float templ_mean = 0;
    float templ_std = 0;
    for (int i = 0; i < h; i++) {
        const uchar* templ_ptr = templ.ptr<uchar>(i);
        for (int j = 0; j < w; j++) {
            templ_mean += templ_ptr[j];
        }
    }
    templ_mean /= (h * w);

    for (int i = 0; i < h; i++) {
        const uchar* templ_ptr = templ.ptr<uchar>(i);
        for (int j = 0; j < w; j++) {
            float diff = templ_ptr[j] - templ_mean;
            templ_std += diff * diff;
        }
    }
    templ_std = sqrt(templ_std / (h * w));

    #pragma omp parallel for
    for (int y = 0; y < H-h+1; y++) {
        for (int x = 0; x < W-w+1; x++) {
            // è®¡ç®—çª—å£çš„å‡å€¼å’Œæ ‡å‡†å·®
            float window_mean = 0;
            float window_std = 0;
            float zncc = 0;

            for (int i = 0; i < h; i++) {
                const uchar* src_ptr = src.ptr<uchar>(y+i) + x;
                for (int j = 0; j < w; j++) {
                    window_mean += src_ptr[j];
                }
            }
            window_mean /= (h * w);

            for (int i = 0; i < h; i++) {
                const uchar* src_ptr = src.ptr<uchar>(y+i) + x;
                const uchar* templ_ptr = templ.ptr<uchar>(i);
                for (int j = 0; j < w; j++) {
                    float src_diff = src_ptr[j] - window_mean;
                    float templ_diff = templ_ptr[j] - templ_mean;
                    window_std += src_diff * src_diff;
                    zncc += src_diff * templ_diff;
                }
            }
            window_std = sqrt(window_std / (h * w));

            if (window_std > 0 && templ_std > 0) {
                result.at<float>(y, x) = zncc / (window_std * templ_std * h * w);
            }
        }
    }
}
```

### 5.3 Pythonå®ç°

```python
def zncc_matching(img_path, template_path):
    """
    ä½¿ç”¨é›¶å‡å€¼å½’ä¸€åŒ–äº’ç›¸å…³è¿›è¡Œæ¨¡æ¿åŒ¹é…
    """
    # è¯»å–å›¾åƒ
    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
    template = cv2.imread(template_path, cv2.IMREAD_GRAYSCALE)
    if img is None or template is None:
        raise ValueError("æ— æ³•è¯»å–å›¾åƒ")

    h, w = template.shape
    H, W = img.shape
    result = np.zeros((H-h+1, W-w+1), dtype=np.float32)

    # è®¡ç®—æ¨¡æ¿çš„å‡å€¼å’Œæ ‡å‡†å·®
    template_mean = np.mean(template)
    template_std = np.std(template)

    # è®¡ç®—ZNCC
    for y in range(H-h+1):
        for x in range(W-w+1):
            window = img[y:y+h, x:x+w]
            window_mean = np.mean(window)
            window_std = np.std(window)
            if window_std > 0 and template_std > 0:
                zncc = np.sum((window - window_mean) * (template - template_mean)) / (window_std * template_std * h * w)
                result[y, x] = zncc

    # å½’ä¸€åŒ–ç»“æœ
    result = cv2.normalize(result, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)

    # æ‰¾åˆ°æœ€ä½³åŒ¹é…ä½ç½®
    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
    top_left = max_loc  # ZNCCä½¿ç”¨æœ€å¤§å€¼
    bottom_right = (top_left[0] + w, top_left[1] + h)

    # åœ¨åŸå›¾ä¸Šç»˜åˆ¶çŸ©å½¢æ¡†
    img_color = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
    cv2.rectangle(img_color, top_left, bottom_right, (0, 0, 255), 2)

    return img_color
```

## 6. ç‰¹å¾ç‚¹åŒ¹é…ï¼šå›¾åƒä¸­çš„"å…³é”®ç‚¹"å¯»æ‰¾

### 6.1 åŸºæœ¬æµç¨‹

1. ç‰¹å¾ç‚¹æ£€æµ‹ï¼ˆæ‰¾åˆ°"å…³é”®ç‚¹"ï¼‰
2. ç‰¹å¾æè¿°ï¼ˆæè¿°"å…³é”®ç‚¹"çš„ç‰¹å¾ï¼‰
3. ç‰¹å¾åŒ¹é…ï¼ˆæ‰¾åˆ°"ç›¸ä¼¼"çš„ç‰¹å¾ç‚¹ï¼‰
4. è¯¯åŒ¹é…å‰”é™¤ï¼ˆå»æ‰"é”™è¯¯"çš„åŒ¹é…ï¼‰

### 6.2 å¸¸ç”¨ç®—æ³•

- ğŸ”‘ SIFTï¼ˆScale-Invariant Feature Transformï¼‰
- ğŸ¯ SURFï¼ˆSpeeded-Up Robust Featuresï¼‰
- ğŸš€ ORBï¼ˆOriented FAST and Rotated BRIEFï¼‰

### 6.3 C++å®ç°

```cpp
void feature_point_matching(const Mat& src1, const Mat& src2,
                          vector<DMatch>& matches,
                          vector<KeyPoint>& keypoints1,
                          vector<KeyPoint>& keypoints2) {
    // åˆ›å»ºSIFTæ£€æµ‹å™¨
    Ptr<SIFT> sift = SIFT::create();

    // æ£€æµ‹å…³é”®ç‚¹å’Œè®¡ç®—æè¿°å­
    Mat descriptors1, descriptors2;
    sift->detectAndCompute(src1, noArray(), keypoints1, descriptors1);
    sift->detectAndCompute(src2, noArray(), keypoints2, descriptors2);

    // åˆ›å»ºFLANNåŒ¹é…å™¨
    Ptr<DescriptorMatcher> matcher = DescriptorMatcher::create(DescriptorMatcher::FLANNBASED);
    vector<vector<DMatch>> knn_matches;
    matcher->knnMatch(descriptors1, descriptors2, knn_matches, 2);

    // ä½¿ç”¨Loweæ¯”ç‡æµ‹è¯•å‰”é™¤è¯¯åŒ¹é…
    const float ratio_thresh = 0.7f;
    matches.clear();
    for (size_t i = 0; i < knn_matches.size(); i++) {
        if (knn_matches[i][0].distance < ratio_thresh * knn_matches[i][1].distance) {
            matches.push_back(knn_matches[i][0]);
        }
    }
}
```

### 6.4 Pythonå®ç°

```python
def feature_point_matching(img_path1, img_path2):
    """
    ä½¿ç”¨ç‰¹å¾æè¿°å­è¿›è¡Œå›¾åƒåŒ¹é…
    """
    # è¯»å–å›¾åƒ
    img1 = cv2.imread(img_path1)
    img2 = cv2.imread(img_path2)
    if img1 is None or img2 is None:
        raise ValueError("æ— æ³•è¯»å–å›¾åƒ")

    # è½¬æ¢ä¸ºç°åº¦å›¾
    gray1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)
    gray2 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)

    # åˆ›å»ºSIFTæ£€æµ‹å™¨
    sift = cv2.SIFT_create()

    # æ£€æµ‹å…³é”®ç‚¹å’Œè®¡ç®—æè¿°å­
    keypoints1, descriptors1 = sift.detectAndCompute(gray1, None)
    keypoints2, descriptors2 = sift.detectAndCompute(gray2, None)

    # åˆ›å»ºBFåŒ¹é…å™¨
    bf = cv2.BFMatcher(cv2.NORM_L2, crossCheck=True)

    # è¿›è¡Œç‰¹å¾åŒ¹é…
    matches = bf.match(descriptors1, descriptors2)

    # æŒ‰è·ç¦»æ’åº
    matches = sorted(matches, key=lambda x: x.distance)

    # ç»˜åˆ¶å‰10ä¸ªåŒ¹é…
    result = cv2.drawMatches(img1, keypoints1, img2, keypoints2, matches[:10], None,
                            flags=cv2.DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS)

    return result
```

## 7. ä»£ç å®ç°ä¸ä¼˜åŒ–ï¼šè®©åŒ¹é…æ›´"å¿«"æ›´"å‡†"

### 7.1 å®ç°ç¤ºä¾‹

```cpp
// ä½¿ç”¨ç§¯åˆ†å›¾åŠ é€ŸNCCè®¡ç®—
void computeIntegralImage(const Mat& src, Mat& integral) {
    integral = Mat::zeros(src.rows + 1, src.cols + 1, CV_32F);
    for(int y = 0; y < src.rows; y++) {
        for(int x = 0; x < src.cols; x++) {
            integral.at<float>(y + 1, x + 1) =
                src.at<uchar>(y, x) +
                integral.at<float>(y, x + 1) +
                integral.at<float>(y + 1, x) -
                integral.at<float>(y, x);
        }
    }
}
```

## 8. åº”ç”¨åœºæ™¯ä¸å®è·µï¼šä»ç†è®ºåˆ°"å®æˆ˜"

### 8.1 å…¸å‹åº”ç”¨

- ğŸ“± äººè„¸è¯†åˆ«
- ğŸš— è½¦ç‰Œè¯†åˆ«
- ğŸ–¼ï¸ å›¾åƒæ‹¼æ¥
- ğŸ¯ ç›®æ ‡è·Ÿè¸ª
- ğŸ” å›¾åƒæ£€ç´¢

### 8.2 å®è·µå»ºè®®

1. ç®—æ³•é€‰æ‹©
   - æ ¹æ®åº”ç”¨åœºæ™¯é€‰æ‹©åˆé€‚çš„ç®—æ³•
   - è€ƒè™‘è®¡ç®—æ•ˆç‡å’Œå‡†ç¡®æ€§
   - æƒè¡¡å®æ—¶æ€§å’Œç²¾åº¦

2. å‚æ•°è°ƒä¼˜
   - æ¨¡æ¿å¤§å°é€‰æ‹©
   - ç›¸ä¼¼åº¦é˜ˆå€¼è®¾ç½®
   - å¤šå°ºåº¦å‚æ•°è°ƒæ•´

3. å·¥ç¨‹å®ç°
   - å†…å­˜ä¼˜åŒ–
   - å¹¶è¡Œè®¡ç®—
   - ç¡¬ä»¶åŠ é€Ÿ

## å‚è€ƒèµ„æ–™

1. ğŸ“š Lewis, J. P. (1995). Fast normalized cross-correlation.
2. ğŸ“– Lowe, D. G. (2004). Distinctive image features from scale-invariant keypoints.
3. ğŸ”¬ Bay, H., et al. (2008). Speeded-up robust features (SURF).
4. ğŸ“Š Rublee, E., et al. (2011). ORB: An efficient alternative to SIFT or SURF.

## æ€»ç»“

å›¾åƒåŒ¹é…å°±åƒæ˜¯è®¡ç®—æœºçš„"æ‰¾ä¸åŒ"æ¸¸æˆï¼Œé€šè¿‡SSDã€SADã€NCCã€ZNCCç­‰ä¸åŒçš„åŒ¹é…æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ°å›¾åƒä¸­çš„ç›¸ä¼¼éƒ¨åˆ†ã€‚æ— è®ºæ˜¯ç”¨äºç›®æ ‡æ£€æµ‹ã€å›¾åƒæ‹¼æ¥è¿˜æ˜¯ç‰¹å¾ç‚¹åŒ¹é…ï¼Œé€‰æ‹©åˆé€‚çš„åŒ¹é…æ–¹æ³•éƒ½æ˜¯å…³é”®ã€‚å¸Œæœ›è¿™ç¯‡æ•™ç¨‹èƒ½å¸®åŠ©ä½ æ›´å¥½åœ°ç†è§£å’Œåº”ç”¨å›¾åƒåŒ¹é…æŠ€æœ¯ï¼ğŸ¯

> ğŸ’¡ å°è´´å£«ï¼šåœ¨å®é™…åº”ç”¨ä¸­ï¼Œå»ºè®®æ ¹æ®å…·ä½“åœºæ™¯é€‰æ‹©åˆé€‚çš„åŒ¹é…æ–¹æ³•ï¼Œå¹¶æ³¨æ„åŒ¹é…çš„å‡†ç¡®æ€§å’Œè®¡ç®—æ•ˆç‡ã€‚åŒæ—¶ï¼Œåˆç†ä½¿ç”¨ç‰¹å¾ç‚¹åŒ¹é…ç­‰é«˜çº§æŠ€æœ¯ï¼Œè¿™æ ·æ‰èƒ½åœ¨å®é™…é¡¹ç›®ä¸­æ¸¸åˆƒæœ‰ä½™ï¼